{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Godot RTS Entity Controller Documentation Welcome to the Godot RTS Entity Controller addon documentation. This addon is a comprehensive toolkit for building Real-Time Strategy (RTS) games in Godot and includes ready to use components for selecting, moving, attack units or buildings and casting abilities . The play and feel of these components (especially the movement and combat system) is heavily inspired by Starcraft 2 , which should make people familiar with it feel right at home. This means you will find all the basic controlling blocks, such as moving, patrolling, move-attacking or casting abilities for units (or buildings) that you are used from Starcraft 2. As a result one of the highlights of this addon is the responsive control over units, best suited for RTS or RTT games with unit counts in the tens or low hundreds. The systems in this addon were not developed for armies of thousands of units, but rather optimized for a high degree of control, modularity and customization over the behaviours of units. Quick Start New to the addon? Start here: Getting Started - Installation and basic setup Core Concepts - Understand the architecture Documentation Structure Systems & Features Player Input System - Selection, movement commands, and camera control Entities - Creating entities using building blocks Selection System - Unit selection and group management Movement & Navigation - Unit pathfinding and movement Abilities System - Creating and using custom abilities Combat System - Auto targeting, weapon and combat systems Autoloads - Controller and utility logic Components Deep Dive Component Overview - Component system overview Selectable Component - Making units selectable Movable Component - Movement capabilities Health Component - Health and damage Defense Component - Defense and damage reduction Attack Component - Attacking and weapons Visual Component - Pivots and visuals Advanced Topics Spatial Hashing - Performance optimization Reference Best Practices - Tips and patterns Troubleshooting - Common issues and solutions Features Selection System - Select individual or multiple units with box selection Movement & Navigation - Pathfinding and group movement Combat - Attack systems, abilities, and damage Animation - AnimationTree integration for smooth animations Events - Decoupled communication via event bus Performance - Spatial hashing for efficient queries Extensible - Component-based architecture for easy customization Downloadable Content Godot Addon : All scripts, basic unit templates, and essential assets are included free in the open source project on Github Free Demo : A free executable demonstrating more advanced units and abilities can be found on itch.io Example Project (Paid): An example project containing more advanced units and abilities, as well as assets, can be found on itch.io Support For issues, questions, or suggestions, please refer to the Troubleshooting section or check the repository issues.","title":"Home"},{"location":"#godot-rts-entity-controller-documentation","text":"Welcome to the Godot RTS Entity Controller addon documentation. This addon is a comprehensive toolkit for building Real-Time Strategy (RTS) games in Godot and includes ready to use components for selecting, moving, attack units or buildings and casting abilities . The play and feel of these components (especially the movement and combat system) is heavily inspired by Starcraft 2 , which should make people familiar with it feel right at home. This means you will find all the basic controlling blocks, such as moving, patrolling, move-attacking or casting abilities for units (or buildings) that you are used from Starcraft 2. As a result one of the highlights of this addon is the responsive control over units, best suited for RTS or RTT games with unit counts in the tens or low hundreds. The systems in this addon were not developed for armies of thousands of units, but rather optimized for a high degree of control, modularity and customization over the behaviours of units.","title":"Godot RTS Entity Controller Documentation"},{"location":"#quick-start","text":"New to the addon? Start here: Getting Started - Installation and basic setup Core Concepts - Understand the architecture","title":"Quick Start"},{"location":"#documentation-structure","text":"","title":"Documentation Structure"},{"location":"#systems-features","text":"Player Input System - Selection, movement commands, and camera control Entities - Creating entities using building blocks Selection System - Unit selection and group management Movement & Navigation - Unit pathfinding and movement Abilities System - Creating and using custom abilities Combat System - Auto targeting, weapon and combat systems Autoloads - Controller and utility logic","title":"Systems &amp; Features"},{"location":"#components-deep-dive","text":"Component Overview - Component system overview Selectable Component - Making units selectable Movable Component - Movement capabilities Health Component - Health and damage Defense Component - Defense and damage reduction Attack Component - Attacking and weapons Visual Component - Pivots and visuals","title":"Components Deep Dive"},{"location":"#advanced-topics","text":"Spatial Hashing - Performance optimization","title":"Advanced Topics"},{"location":"#reference","text":"Best Practices - Tips and patterns Troubleshooting - Common issues and solutions","title":"Reference"},{"location":"#features","text":"Selection System - Select individual or multiple units with box selection Movement & Navigation - Pathfinding and group movement Combat - Attack systems, abilities, and damage Animation - AnimationTree integration for smooth animations Events - Decoupled communication via event bus Performance - Spatial hashing for efficient queries Extensible - Component-based architecture for easy customization","title":"Features"},{"location":"#downloadable-content","text":"Godot Addon : All scripts, basic unit templates, and essential assets are included free in the open source project on Github Free Demo : A free executable demonstrating more advanced units and abilities can be found on itch.io Example Project (Paid): An example project containing more advanced units and abilities, as well as assets, can be found on itch.io","title":"Downloadable Content"},{"location":"#support","text":"For issues, questions, or suggestions, please refer to the Troubleshooting section or check the repository issues.","title":"Support"},{"location":"core-concepts/","text":"Core Concepts Architecture Overview The Godot RTS Entity Controller is built on a component-based architecture with an event-driven communication system. Component System Units (also referred to as Entities) are composed of modular components that add specific behaviors: Components extend from a base Component class Each component handles a specific aspect of unit behavior (movement, health, selection, etc.) Components communicate via signals and the event bus Components can be mixed and matched to create different unit types Event Bus Pattern The RTS_EventBus provides decoupled communication: Components emit events when things happen (unit selected, moved, damaged, etc.) Other systems listen for events without needing direct references Enables loose coupling and modularity Autoload System Three core autoloads manage the overall system: RTS_EventBus - Central event dispatcher RTSController - Manages selected units and global state RTS_PlayerInput - Handles input commands and translates them to gameplay actions Key Design Patterns 1. Component Pattern Units are built from reusable, composable components rather than deep inheritance hierarchies. 2. Event-Driven Communication Systems communicate through events rather than direct references, promoting loose coupling. 3. Separation of Concerns Input layer handles player commands Selection layer manages which units are selected Command layer translates selections into unit actions Component layer implements actual behaviors 4. Scene-Based Everything is a Godot scene or node, making it familiar to Godot developers. Data Flow Player Input \u2193 RTS_PlayerInput (collects input to distribute) \u2193 Selection/AbilityManager (interpret input) \u2193 Components (implement logic) \u2193 Visual/Audio Updates Note that if one chooses, player input can be handled completely differently, for example when integrating with an existing player input system. All that's required is to send the required input data to Selection and AbilityManager to interpret the input. Entity Structure A typical entity consists of: Entity (RTS_Entity) \u251c\u2500\u2500 Components (RTS_Movable, RTS_Selectable, etc.) \u251c\u2500\u2500 Model (visual representation) \u2514\u2500\u2500 Sub-components (weapons, attachments, etc.) Components are \"composed into\" units rather than units inheriting from them. See Entity System for details. Selection Model Selection is managed globally by the RTSController Units can be selected or deselected Multiple units can be selected simultaneously Selection groups be assign to hotkeys (1-9) Selection changes trigger events that other systems listen to See Selection System for details. Navigation & Movement Uses Godot's built-in NavigationServer3D for static pathfinding RTS_Movable handles unit-specific movement logic, including separation, avoidance, etc Supports both individual movement and group movement See Movement & Navigation for details. Combat & Abilities Attacks are handled by weapon components Abilities are special actions with cooldowns and effects Both use the event bus to communicate results See Combat System for details. Performance Considerations Spatial Hashing optimizes spatial queries (finding nearby units) Collision layers help with efficient physics queries Components only process what they need each frame See Advanced Topics for optimization details.","title":"Core Concepts"},{"location":"core-concepts/#core-concepts","text":"","title":"Core Concepts"},{"location":"core-concepts/#architecture-overview","text":"The Godot RTS Entity Controller is built on a component-based architecture with an event-driven communication system.","title":"Architecture Overview"},{"location":"core-concepts/#component-system","text":"Units (also referred to as Entities) are composed of modular components that add specific behaviors: Components extend from a base Component class Each component handles a specific aspect of unit behavior (movement, health, selection, etc.) Components communicate via signals and the event bus Components can be mixed and matched to create different unit types","title":"Component System"},{"location":"core-concepts/#event-bus-pattern","text":"The RTS_EventBus provides decoupled communication: Components emit events when things happen (unit selected, moved, damaged, etc.) Other systems listen for events without needing direct references Enables loose coupling and modularity","title":"Event Bus Pattern"},{"location":"core-concepts/#autoload-system","text":"Three core autoloads manage the overall system: RTS_EventBus - Central event dispatcher RTSController - Manages selected units and global state RTS_PlayerInput - Handles input commands and translates them to gameplay actions","title":"Autoload System"},{"location":"core-concepts/#key-design-patterns","text":"","title":"Key Design Patterns"},{"location":"core-concepts/#1-component-pattern","text":"Units are built from reusable, composable components rather than deep inheritance hierarchies.","title":"1. Component Pattern"},{"location":"core-concepts/#2-event-driven-communication","text":"Systems communicate through events rather than direct references, promoting loose coupling.","title":"2. Event-Driven Communication"},{"location":"core-concepts/#3-separation-of-concerns","text":"Input layer handles player commands Selection layer manages which units are selected Command layer translates selections into unit actions Component layer implements actual behaviors","title":"3. Separation of Concerns"},{"location":"core-concepts/#4-scene-based","text":"Everything is a Godot scene or node, making it familiar to Godot developers.","title":"4. Scene-Based"},{"location":"core-concepts/#data-flow","text":"Player Input \u2193 RTS_PlayerInput (collects input to distribute) \u2193 Selection/AbilityManager (interpret input) \u2193 Components (implement logic) \u2193 Visual/Audio Updates Note that if one chooses, player input can be handled completely differently, for example when integrating with an existing player input system. All that's required is to send the required input data to Selection and AbilityManager to interpret the input.","title":"Data Flow"},{"location":"core-concepts/#entity-structure","text":"A typical entity consists of: Entity (RTS_Entity) \u251c\u2500\u2500 Components (RTS_Movable, RTS_Selectable, etc.) \u251c\u2500\u2500 Model (visual representation) \u2514\u2500\u2500 Sub-components (weapons, attachments, etc.) Components are \"composed into\" units rather than units inheriting from them. See Entity System for details.","title":"Entity Structure"},{"location":"core-concepts/#selection-model","text":"Selection is managed globally by the RTSController Units can be selected or deselected Multiple units can be selected simultaneously Selection groups be assign to hotkeys (1-9) Selection changes trigger events that other systems listen to See Selection System for details.","title":"Selection Model"},{"location":"core-concepts/#navigation-movement","text":"Uses Godot's built-in NavigationServer3D for static pathfinding RTS_Movable handles unit-specific movement logic, including separation, avoidance, etc Supports both individual movement and group movement See Movement & Navigation for details.","title":"Navigation &amp; Movement"},{"location":"core-concepts/#combat-abilities","text":"Attacks are handled by weapon components Abilities are special actions with cooldowns and effects Both use the event bus to communicate results See Combat System for details.","title":"Combat &amp; Abilities"},{"location":"core-concepts/#performance-considerations","text":"Spatial Hashing optimizes spatial queries (finding nearby units) Collision layers help with efficient physics queries Components only process what they need each frame See Advanced Topics for optimization details.","title":"Performance Considerations"},{"location":"getting-started/","text":"Getting Started Installation Clone the repository Add the godot-rts-entity-controller folder into your project's addons/ directory Open your Godot project and navigate to Project > Project Settings > Plugins Find the Godot RTS Entity Controller plugin and click Enable Basic Setup 1. Enable Required Autoloads The addon requires several autoloads to function. These should be automatically added during plugin initialization: RTSController - Main scene handling camera & unit controls RTS_PlayerInput - Handles player input and commands RTS_EventBus - Central event system Check Project > Project Settings > Autoload to verify they're present. 2. Verify RTS Settings Make yourself familiar with the global settings found at rts_settings.tres, such as collision layer, input and debugging settings. Adjust collision layers if they are conflicting with your existing project. 3. Create Your First Unit Create a scene with the following structure: Unit (Node3D) \u251c\u2500\u2500 Model (Node3D or MeshInstance3D) \u251c\u2500\u2500 SelectableComponent \u251c\u2500\u2500 MovableComponent \u251c\u2500\u2500 HealthComponent \u2514\u2500\u2500 (other components as needed) Check ExampleUnit.tscn for a minimal but fully set up unit. For more details on the unit & component setup check the Component section. 4. Set Up a Basic Level Create a level scene with: Level (Node3D) \u251c\u2500\u2500 NavigationRegion3D (with NavMesh for pathfinding) \u251c\u2500\u2500 Ground/Terrain \u251c\u2500\u2500 Units (instantiate your unit scenes) \u251c\u2500\u2500 PhysicsCatchLayer \u251c\u2500\u2500 SpatialHashArea \u2514\u2500\u2500 CameraBoundaryAndPosition (if using Camera bounds) Check ExampleScene.tscn for a demonstration of a ready to play scene! Next Steps Read Core Concepts to understand the architecture Explore Components to build your units Check out the examples folder in the addon for reference implementations","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"Clone the repository Add the godot-rts-entity-controller folder into your project's addons/ directory Open your Godot project and navigate to Project > Project Settings > Plugins Find the Godot RTS Entity Controller plugin and click Enable","title":"Installation"},{"location":"getting-started/#basic-setup","text":"","title":"Basic Setup"},{"location":"getting-started/#1-enable-required-autoloads","text":"The addon requires several autoloads to function. These should be automatically added during plugin initialization: RTSController - Main scene handling camera & unit controls RTS_PlayerInput - Handles player input and commands RTS_EventBus - Central event system Check Project > Project Settings > Autoload to verify they're present.","title":"1. Enable Required Autoloads"},{"location":"getting-started/#2-verify-rts-settings","text":"Make yourself familiar with the global settings found at rts_settings.tres, such as collision layer, input and debugging settings. Adjust collision layers if they are conflicting with your existing project.","title":"2. Verify RTS Settings"},{"location":"getting-started/#3-create-your-first-unit","text":"Create a scene with the following structure: Unit (Node3D) \u251c\u2500\u2500 Model (Node3D or MeshInstance3D) \u251c\u2500\u2500 SelectableComponent \u251c\u2500\u2500 MovableComponent \u251c\u2500\u2500 HealthComponent \u2514\u2500\u2500 (other components as needed) Check ExampleUnit.tscn for a minimal but fully set up unit. For more details on the unit & component setup check the Component section.","title":"3. Create Your First Unit"},{"location":"getting-started/#4-set-up-a-basic-level","text":"Create a level scene with: Level (Node3D) \u251c\u2500\u2500 NavigationRegion3D (with NavMesh for pathfinding) \u251c\u2500\u2500 Ground/Terrain \u251c\u2500\u2500 Units (instantiate your unit scenes) \u251c\u2500\u2500 PhysicsCatchLayer \u251c\u2500\u2500 SpatialHashArea \u2514\u2500\u2500 CameraBoundaryAndPosition (if using Camera bounds) Check ExampleScene.tscn for a demonstration of a ready to play scene!","title":"4. Set Up a Basic Level"},{"location":"getting-started/#next-steps","text":"Read Core Concepts to understand the architecture Explore Components to build your units Check out the examples folder in the addon for reference implementations","title":"Next Steps"},{"location":"advanced/spatial-hashing/","text":"Spatial Hashing Godots native collisios checks are usually very fast and well integrated. Therefore this tool uses Area3D and CharacterBody4D's built in collision checks and events on many occasions. However, for more flexibility and in order to perform custom qeueries, a spatial hashing system implemented in gdscript is provided. A good example to check its use is RTS_DamageDealerAoE which uses RTS_SpatialHashArea.main_grid.find_entities(...) to find nearby entities. Overview Apart from RTS_SpatialHashArea , the remaining spatial hash scripts (RTS_HashClient, RTS_SpatialHashFast, RTS_SpatialHashUtils, RTS_HashNode) can be used as an independent library, as they are self containing. Spatial hashing divides the map into a grid for faster spatial queries. Benefits Fast spatial queries - O(1) instead of O(n) Better performance - Especially with many units Efficient updates - Only rebuild affected cells Scalable - Works with large maps and unit counts Basic Implementation While the internal spatial hashing algorithms are complex, the RTS_SpatialHashArea component provides a simple interface for querying entities efficiently. RTS_SpatialHashArea Component RTS_SpatialHashArea is an Area3D that automatically manages a spatial hash grid for fast entity lookups. Setup Create a scene with an RTS_SpatialHashArea node and a CollisionShape3D child: Level (Node3D) \u251c\u2500\u2500 RTS_SpatialHashArea (Area3D) \u2502 \u2514\u2500\u2500 CollisionShape3D (BoxShape3D) \u2514\u2500\u2500 Units... Properties @export var id: String = \"1\" # Unique identifier for the grid @export var INIT_CELL_SIZE = 1.0 # Size of each grid cell (larger = fewer cells) @export var visual_debug: bool = false # Visualize grid (requires DebugDraw3D addon) @export var auto_update_clients: bool = false # Auto-update entity positions each frame How It Works Automatic Registration - When an RTS_Entity with space_hash = true enters the scene, it's automatically added to the grid Grid Cells - The collision shape defines the grid bounds; cell size determines query speed vs accuracy Position Tracking - Entity positions update in the grid (manually or automatically) Fast Queries - Find entities by position/radius in O(1) time instead of O(n) Static Main Grid The last RTS_SpatialHashArea running in the scene becomes the main grid: # (in _ready) #set main_grid main_grid = self # Access globally var nearby = RTS_SpatialHashArea.main_grid.find_entities(position, radius, exact=false) Overwrite this functionality if you want to assign main_grid in a different fashion. It is important that this main_grid is set, as most queries will use the main_grid to query by default. Ofcourse it is possible use multiple SpatialHashAreas and query them independently as well. Common Methods Query entities by position: # Find by radius var entities = spatial_hash.find_entities(position, radius, exact=false) # Find by bounds (Vector2 x/z size) var entities = spatial_hash.find_entities_bounds(position, bounds, exact=false) # Find by AABB (3D bounding box) var entities = spatial_hash.find_entities_using_aabb(aabb, exact=true) # exact=true: Precise distance checks # exact=false: Faster, grid-based checks Faction Filtering Find only enemies or allies: # Group parameter: -1 = all, 0 = PLAYER faction, 1 = ENEMY faction, 2 = NEUTRAL var enemies = spatial_hash.find_entities(position, radius, exact=false, group=1) Cell Size Tuning Larger cells = Fewer cells to check, but more false positives INIT_CELL_SIZE = 5.0 # Each cell is 5x5 units Smaller cells = More accurate but slower INIT_CELL_SIZE = 1.0 # Each cell is 1x1 units Rule of thumb : Set cell size roughly equal to average entity search radius Example Usage # Find nearby enemies to attack func find_targets(attack_range: float) -> Array[RTS_Entity]: var nearby = RTS_SpatialHashArea.main_grid.find_entities( global_position, attack_range, exact=false, group=RTS_Entity.Faction.ENEMY ) return nearby # Check if area is clear of enemies func is_area_clear(center: Vector3, radius: float) -> bool: var enemies = RTS_SpatialHashArea.main_grid.find_entities( center, radius, exact=true, group=RTS_Entity.Faction.ENEMY ) return enemies.is_empty() Manual Updates If auto_update_clients = false , manually update positions: # Call when entities move significantly RTS_SpatialHashArea.main_grid.update_clients() If false, make sure to call this before doing any queries. Visual Debugging Consider adding the DebugDraw3D addon to debug the grid. This draws grid cells and entity positions for troubleshooting. See Also Best Practices - Performance tips Core Concepts - System architecture","title":"Spatial Hashing"},{"location":"advanced/spatial-hashing/#spatial-hashing","text":"Godots native collisios checks are usually very fast and well integrated. Therefore this tool uses Area3D and CharacterBody4D's built in collision checks and events on many occasions. However, for more flexibility and in order to perform custom qeueries, a spatial hashing system implemented in gdscript is provided. A good example to check its use is RTS_DamageDealerAoE which uses RTS_SpatialHashArea.main_grid.find_entities(...) to find nearby entities.","title":"Spatial Hashing"},{"location":"advanced/spatial-hashing/#overview","text":"Apart from RTS_SpatialHashArea , the remaining spatial hash scripts (RTS_HashClient, RTS_SpatialHashFast, RTS_SpatialHashUtils, RTS_HashNode) can be used as an independent library, as they are self containing. Spatial hashing divides the map into a grid for faster spatial queries.","title":"Overview"},{"location":"advanced/spatial-hashing/#benefits","text":"Fast spatial queries - O(1) instead of O(n) Better performance - Especially with many units Efficient updates - Only rebuild affected cells Scalable - Works with large maps and unit counts","title":"Benefits"},{"location":"advanced/spatial-hashing/#basic-implementation","text":"While the internal spatial hashing algorithms are complex, the RTS_SpatialHashArea component provides a simple interface for querying entities efficiently.","title":"Basic Implementation"},{"location":"advanced/spatial-hashing/#rts_spatialhasharea-component","text":"RTS_SpatialHashArea is an Area3D that automatically manages a spatial hash grid for fast entity lookups.","title":"RTS_SpatialHashArea Component"},{"location":"advanced/spatial-hashing/#setup","text":"Create a scene with an RTS_SpatialHashArea node and a CollisionShape3D child: Level (Node3D) \u251c\u2500\u2500 RTS_SpatialHashArea (Area3D) \u2502 \u2514\u2500\u2500 CollisionShape3D (BoxShape3D) \u2514\u2500\u2500 Units...","title":"Setup"},{"location":"advanced/spatial-hashing/#properties","text":"@export var id: String = \"1\" # Unique identifier for the grid @export var INIT_CELL_SIZE = 1.0 # Size of each grid cell (larger = fewer cells) @export var visual_debug: bool = false # Visualize grid (requires DebugDraw3D addon) @export var auto_update_clients: bool = false # Auto-update entity positions each frame","title":"Properties"},{"location":"advanced/spatial-hashing/#how-it-works","text":"Automatic Registration - When an RTS_Entity with space_hash = true enters the scene, it's automatically added to the grid Grid Cells - The collision shape defines the grid bounds; cell size determines query speed vs accuracy Position Tracking - Entity positions update in the grid (manually or automatically) Fast Queries - Find entities by position/radius in O(1) time instead of O(n)","title":"How It Works"},{"location":"advanced/spatial-hashing/#static-main-grid","text":"The last RTS_SpatialHashArea running in the scene becomes the main grid: # (in _ready) #set main_grid main_grid = self # Access globally var nearby = RTS_SpatialHashArea.main_grid.find_entities(position, radius, exact=false) Overwrite this functionality if you want to assign main_grid in a different fashion. It is important that this main_grid is set, as most queries will use the main_grid to query by default. Ofcourse it is possible use multiple SpatialHashAreas and query them independently as well.","title":"Static Main Grid"},{"location":"advanced/spatial-hashing/#common-methods","text":"Query entities by position: # Find by radius var entities = spatial_hash.find_entities(position, radius, exact=false) # Find by bounds (Vector2 x/z size) var entities = spatial_hash.find_entities_bounds(position, bounds, exact=false) # Find by AABB (3D bounding box) var entities = spatial_hash.find_entities_using_aabb(aabb, exact=true) # exact=true: Precise distance checks # exact=false: Faster, grid-based checks","title":"Common Methods"},{"location":"advanced/spatial-hashing/#faction-filtering","text":"Find only enemies or allies: # Group parameter: -1 = all, 0 = PLAYER faction, 1 = ENEMY faction, 2 = NEUTRAL var enemies = spatial_hash.find_entities(position, radius, exact=false, group=1)","title":"Faction Filtering"},{"location":"advanced/spatial-hashing/#cell-size-tuning","text":"Larger cells = Fewer cells to check, but more false positives INIT_CELL_SIZE = 5.0 # Each cell is 5x5 units Smaller cells = More accurate but slower INIT_CELL_SIZE = 1.0 # Each cell is 1x1 units Rule of thumb : Set cell size roughly equal to average entity search radius","title":"Cell Size Tuning"},{"location":"advanced/spatial-hashing/#example-usage","text":"# Find nearby enemies to attack func find_targets(attack_range: float) -> Array[RTS_Entity]: var nearby = RTS_SpatialHashArea.main_grid.find_entities( global_position, attack_range, exact=false, group=RTS_Entity.Faction.ENEMY ) return nearby # Check if area is clear of enemies func is_area_clear(center: Vector3, radius: float) -> bool: var enemies = RTS_SpatialHashArea.main_grid.find_entities( center, radius, exact=true, group=RTS_Entity.Faction.ENEMY ) return enemies.is_empty()","title":"Example Usage"},{"location":"advanced/spatial-hashing/#manual-updates","text":"If auto_update_clients = false , manually update positions: # Call when entities move significantly RTS_SpatialHashArea.main_grid.update_clients() If false, make sure to call this before doing any queries.","title":"Manual Updates"},{"location":"advanced/spatial-hashing/#visual-debugging","text":"Consider adding the DebugDraw3D addon to debug the grid. This draws grid cells and entity positions for troubleshooting.","title":"Visual Debugging"},{"location":"advanced/spatial-hashing/#see-also","text":"Best Practices - Performance tips Core Concepts - System architecture","title":"See Also"},{"location":"components/attack/","text":"Attack Component For details on the Attack Component and its interplay with the RTS_AttackVariant , RTS_Weapon and RTS_DamageDealer , see Combat System See Also Combat System - Complete combat overview Abilities System - Special attacks and abilities","title":"Attack"},{"location":"components/attack/#attack-component","text":"For details on the Attack Component and its interplay with the RTS_AttackVariant , RTS_Weapon and RTS_DamageDealer , see Combat System","title":"Attack Component"},{"location":"components/attack/#see-also","text":"Combat System - Complete combat overview Abilities System - Special attacks and abilities","title":"See Also"},{"location":"components/defense/","text":"Defense Component This components requires RTS_Health to translate received damage from attacks and weapons into actual health damage on RTS_Health . It is in a way the couterpart to RTS_AttackComponent , since attack components keep track (and attack) defense components (and not entities or health components). Properties @export var armor: int = 0 @export var atp: int = 20 #RTS_AttackComponent-RTS_Target-Priority. Higher values are considered higher threats. This is different from selection priority. @export var vfxs: Array[RTS_Particles3DContainer] @export var area : Area3D armor is a crude implementation of a damage reduction system. For a more complex armor system you could simply extend RTS_DefenseComponent and override the logic. An important property is the atp attack target priority (stolen from SC2's Automatic Targeting System ), which determins the priority of attacks. The highe the atp , the more this defense component is prioritized by enemy attack components. The optional vfxs takes an array of RTS_Particles3DContainer which are played when being attacked. As with other components, it requires a Area3D area to determin collisions with weapon and scan areas. See Combat System for complete combat details.","title":"Defense"},{"location":"components/defense/#defense-component","text":"This components requires RTS_Health to translate received damage from attacks and weapons into actual health damage on RTS_Health . It is in a way the couterpart to RTS_AttackComponent , since attack components keep track (and attack) defense components (and not entities or health components).","title":"Defense Component"},{"location":"components/defense/#properties","text":"@export var armor: int = 0 @export var atp: int = 20 #RTS_AttackComponent-RTS_Target-Priority. Higher values are considered higher threats. This is different from selection priority. @export var vfxs: Array[RTS_Particles3DContainer] @export var area : Area3D armor is a crude implementation of a damage reduction system. For a more complex armor system you could simply extend RTS_DefenseComponent and override the logic. An important property is the atp attack target priority (stolen from SC2's Automatic Targeting System ), which determins the priority of attacks. The highe the atp , the more this defense component is prioritized by enemy attack components. The optional vfxs takes an array of RTS_Particles3DContainer which are played when being attacked. As with other components, it requires a Area3D area to determin collisions with weapon and scan areas. See Combat System for complete combat details.","title":"Properties"},{"location":"components/health/","text":"Health Component Component that keeps track of entities health. Setting instantiate_health_bar to true will auto instantiate the health_bar.tscn scene for each entity, at the RTS_HealthComponents Node3D position. Apart from a few usual functions ( heal , heal_percentage ), it contains the take_damage function to reduce health, func take_damage(dmg : float): if !component_is_active: return if dmg <= 0 || RTS_Controls.settings.invincibility: return health -= dmg health_changed.emit(self) health_damaged.emit(self) if health <= 0 && !is_dead: die() which emits the death signal func die(): is_dead = true set_component_inactive() death.emit(entity) used by a variety of systems, perhaps most notably used by RTS_Entity to emit the end_of_life signal which turns off any RTS_Component , if this default behaviour is not override. Taking Damage and RTS_Defense Usually scripts don't set the health of RTS_Health directly, but go through RTS_Defense which can \"receive\" damage (for example from other entities, damage dealers, weapons) and the call take_damage in turn. Events signal death(entity: RTS_Entity) signal health_changed(health: RTS_HealthComponent) signal health_damaged(health: RTS_HealthComponent) See Combat System for complete combat details.","title":"Health"},{"location":"components/health/#health-component","text":"Component that keeps track of entities health. Setting instantiate_health_bar to true will auto instantiate the health_bar.tscn scene for each entity, at the RTS_HealthComponents Node3D position. Apart from a few usual functions ( heal , heal_percentage ), it contains the take_damage function to reduce health, func take_damage(dmg : float): if !component_is_active: return if dmg <= 0 || RTS_Controls.settings.invincibility: return health -= dmg health_changed.emit(self) health_damaged.emit(self) if health <= 0 && !is_dead: die() which emits the death signal func die(): is_dead = true set_component_inactive() death.emit(entity) used by a variety of systems, perhaps most notably used by RTS_Entity to emit the end_of_life signal which turns off any RTS_Component , if this default behaviour is not override.","title":"Health Component"},{"location":"components/health/#taking-damage-and-rts_defense","text":"Usually scripts don't set the health of RTS_Health directly, but go through RTS_Defense which can \"receive\" damage (for example from other entities, damage dealers, weapons) and the call take_damage in turn.","title":"Taking Damage and RTS_Defense"},{"location":"components/health/#events","text":"signal death(entity: RTS_Entity) signal health_changed(health: RTS_HealthComponent) signal health_damaged(health: RTS_HealthComponent) See Combat System for complete combat details.","title":"Events"},{"location":"components/movable/","text":"Movable Component The main logic of entity movement. It is modelled after common steering and boid logic and closely tuned to achieve a similar play and feel as Starcraft2. This is by far to most complex component and probably deserves a future refactor. For now, we will go over the different states and explain the exposed properties in more detail. State and Targets RTS_Movable holds a list of RTS_Target , which describe the target position and meta data (for instance whether the target is another RTS_Entity itself, or if there are any callbacks to invoke when reaching a target etc). Most notably, each target is associated with a type enum Type { NULL = 0, #NULL only used for signal emitting since can't emit null variable and for null checks PATROL = 1, #Patrol back and forth between multiple targets MOVE = 2, ATTACK = 3, # Will move to attack a specific target, ignoring anything else. MOVEATTACK = 4 #Moves towards target, but will auto attack enemy entities inbetween when possible. } signifying the type of movement towards this target. The types should be self explanatory to anyone who has played another RTS such as Warcraft or Starcraft. At the same time, a RTS_Movable entity is always in one of the following states at a given time. enum State { IDLE = 0, #if we don't need to follow targets, we don't need this state. This makes things much simpler. #However, I'm keeping it in for now since it might be useful to readd \"entity following\" logic later REACHED_SOURCE_TARGET = 1, HOLD = 2, PATROL = 3, WALK = 4, RETURN_TO_IDLE = 5, #Unit automatically returns to idle position PUSHED = 6 # Unit is pushed by external forces } # <= 2 means unit is stationary, > 2 is moving, > 3 is moving without patrol Types and States are not necessarily the same, as the state describes what current state the movable component is in, whereas the target type gives information on how the next target should be treated. Properties @export_group(\"General\") @export var speed: float = 5 @export var stop_distance : float = 0.25 @export var pivot: Node3D #Node which gets rotated. Note: RTS_Entity node is never rotated to keep things simple @export var steering : Area3D The steering area is used for local avoidance and separation. As can be seen in the ExampleUnit, it is a sphere shape with a fairly small radius around the units, slightly larger thant the entities collision shape itself, used to find immediate neighbors. These neighbors are used for \"separation\" and \"avoidance\" explained further below @export_group(\"Components\") @export var nav_agent: NavigationAgent3D A NavigationAgent3D is required for the seeking component of the movement logic. @export_group(\"Separation\") @export var use_separation :bool = true @export var separation_multiplier : float = 1.0 @export_group(\"Avoidance\") @export var use_avoidance :bool = true @export var avoidance_multiplier : int = 10 @export_group(\"Push\") @export var allow_being_pushed : bool = true Separation, avoidance and pushing behaviour is what sets RTS_Movable entities apart from Godots standard implementation of NavigationAgents. Separation enabled: If two moving entities are about to walk into each other, they a force will be applied (in opposite directions) which separates the entities, allowing them to smoothly pass each other. Avoidance enabled: Avoidance is used to avoid, or walk around, immovable objects or immovable entities. Entities can be immovable, even when having a RTS_Movable component themselves, for example when the ability \"RTS_HoldAbility\" is activated. This default behaviour is implemented here, func is_externally_immovable(_movable: RTS_Movable) -> bool: return sm.current_state == State.HOLD and can often be overriden by other scripts, using the active_controller override. To test avoidance behaviour, try \"holding\" an entity (making it immovable) and then walk into it with another entity. Allow Being Pushed enabled: There are numerous occasions when entities want to push each other (this does not count as separation). For instance an Idling entity (meaning the movement state is IDLE) will always be pushed away from a moving entity that is walking and colliding with it. Enabling this will make it easy and smooth to walk through your own entities. Certain abilities could also make use of this and push other entities out of the way. Controller overrides Movement being the most complex logic in RTS, there are many times when you want to override the behaviour temporarily, for instance because you enable a certain ability. To accomodate this, RTS_Movable holds a list of controllers, #A list of (priority, controller) tuples that can overwrite this scripts physics process var active_controller: Object #Either this or a class that overrides movement, i.e. RTS_AttackVariant var controller_overrides: Array = [] of which only the highest priority controller is considered active and determins the exact movement logic. # RTS_Movable: func add_controller_override(controller: Object, priority: int) -> void: controller_overrides.append({ \"priority\": priority, \"controller\": controller }) controller_overrides.sort_custom(func(a, b): return b[\"priority\"] - a[\"priority\"]) active_controller = controller_overrides[0].controller func remove_controller_override(controller: Object) -> void: controller_overrides = controller_overrides.filter(func(entry): return entry[\"controller\"] != controller) controller_overrides.sort_custom(func(a, b): return b[\"priority\"] - a[\"priority\"]) if controller_overrides.is_empty(): active_controller = null else: active_controller = controller_overrides[0].controller For instance, the most common use is RTS_DefaultAttackVariant , which automatically overrides the default implementation of RTS_Movable when it is active: # RTS_DefaultAttackVariant: func set_component_active(): super.set_component_active() if entity.movable != null: entity.movable.add_controller_override(self,1) func set_component_inactive(): super.set_component_inactive() if entity.movable != null: entity.movable.remove_controller_override(self) Such a controller has to implement exactly two functions: func physics_process_override_movable(delta: float, movable: RTS_Movable) and func is_externally_immovable(movable: RTS_Movable) -> bool: of which we have already discussed the latter further above. This way, RTS_DefaultAttackVariant can implement (override) its own custom movement logic, which is needed because we might not won't to continue to move when we are attacking. Note all the complex boid behaviours and state transitions are taken care of in RTS_Movable . Therefore the overriding controller doesn't have to implement custom movement logic itself, rather, it can run extra condition checks and determin which functions in the RTS_Movable should be execute. In most cases these controller still call movable.sm.updatev([delta]) at some point, which runs the default movement logic in RTS_Movable . To clarify this point, imagine you only want the default movement logic to happen when the current time in seconds in divisible by two. You could add a controller, which checks the time modulo 2, and only calls updatev([delta]) when this condition is true. Events signal after_targets_added(movable: RTS_Movable, targets: Array[RTS_Target]) signal next_target_changed(movable: RTS_Movable) #onyl called for acute target change signal before_all_targets_cleared(movable: RTS_Movable) signal all_targets_cleared(movable: RTS_Movable) signal next_target_just_reached(movable: RTS_Movable, target: RTS_Target) # called just before removal of index signal final_target_reached(movable: RTS_Movable)","title":"Movable"},{"location":"components/movable/#movable-component","text":"The main logic of entity movement. It is modelled after common steering and boid logic and closely tuned to achieve a similar play and feel as Starcraft2. This is by far to most complex component and probably deserves a future refactor. For now, we will go over the different states and explain the exposed properties in more detail.","title":"Movable Component"},{"location":"components/movable/#state-and-targets","text":"RTS_Movable holds a list of RTS_Target , which describe the target position and meta data (for instance whether the target is another RTS_Entity itself, or if there are any callbacks to invoke when reaching a target etc). Most notably, each target is associated with a type enum Type { NULL = 0, #NULL only used for signal emitting since can't emit null variable and for null checks PATROL = 1, #Patrol back and forth between multiple targets MOVE = 2, ATTACK = 3, # Will move to attack a specific target, ignoring anything else. MOVEATTACK = 4 #Moves towards target, but will auto attack enemy entities inbetween when possible. } signifying the type of movement towards this target. The types should be self explanatory to anyone who has played another RTS such as Warcraft or Starcraft. At the same time, a RTS_Movable entity is always in one of the following states at a given time. enum State { IDLE = 0, #if we don't need to follow targets, we don't need this state. This makes things much simpler. #However, I'm keeping it in for now since it might be useful to readd \"entity following\" logic later REACHED_SOURCE_TARGET = 1, HOLD = 2, PATROL = 3, WALK = 4, RETURN_TO_IDLE = 5, #Unit automatically returns to idle position PUSHED = 6 # Unit is pushed by external forces } # <= 2 means unit is stationary, > 2 is moving, > 3 is moving without patrol Types and States are not necessarily the same, as the state describes what current state the movable component is in, whereas the target type gives information on how the next target should be treated.","title":"State and Targets"},{"location":"components/movable/#properties","text":"@export_group(\"General\") @export var speed: float = 5 @export var stop_distance : float = 0.25 @export var pivot: Node3D #Node which gets rotated. Note: RTS_Entity node is never rotated to keep things simple @export var steering : Area3D The steering area is used for local avoidance and separation. As can be seen in the ExampleUnit, it is a sphere shape with a fairly small radius around the units, slightly larger thant the entities collision shape itself, used to find immediate neighbors. These neighbors are used for \"separation\" and \"avoidance\" explained further below @export_group(\"Components\") @export var nav_agent: NavigationAgent3D A NavigationAgent3D is required for the seeking component of the movement logic. @export_group(\"Separation\") @export var use_separation :bool = true @export var separation_multiplier : float = 1.0 @export_group(\"Avoidance\") @export var use_avoidance :bool = true @export var avoidance_multiplier : int = 10 @export_group(\"Push\") @export var allow_being_pushed : bool = true Separation, avoidance and pushing behaviour is what sets RTS_Movable entities apart from Godots standard implementation of NavigationAgents. Separation enabled: If two moving entities are about to walk into each other, they a force will be applied (in opposite directions) which separates the entities, allowing them to smoothly pass each other. Avoidance enabled: Avoidance is used to avoid, or walk around, immovable objects or immovable entities. Entities can be immovable, even when having a RTS_Movable component themselves, for example when the ability \"RTS_HoldAbility\" is activated. This default behaviour is implemented here, func is_externally_immovable(_movable: RTS_Movable) -> bool: return sm.current_state == State.HOLD and can often be overriden by other scripts, using the active_controller override. To test avoidance behaviour, try \"holding\" an entity (making it immovable) and then walk into it with another entity. Allow Being Pushed enabled: There are numerous occasions when entities want to push each other (this does not count as separation). For instance an Idling entity (meaning the movement state is IDLE) will always be pushed away from a moving entity that is walking and colliding with it. Enabling this will make it easy and smooth to walk through your own entities. Certain abilities could also make use of this and push other entities out of the way.","title":"Properties"},{"location":"components/movable/#controller-overrides","text":"Movement being the most complex logic in RTS, there are many times when you want to override the behaviour temporarily, for instance because you enable a certain ability. To accomodate this, RTS_Movable holds a list of controllers, #A list of (priority, controller) tuples that can overwrite this scripts physics process var active_controller: Object #Either this or a class that overrides movement, i.e. RTS_AttackVariant var controller_overrides: Array = [] of which only the highest priority controller is considered active and determins the exact movement logic. # RTS_Movable: func add_controller_override(controller: Object, priority: int) -> void: controller_overrides.append({ \"priority\": priority, \"controller\": controller }) controller_overrides.sort_custom(func(a, b): return b[\"priority\"] - a[\"priority\"]) active_controller = controller_overrides[0].controller func remove_controller_override(controller: Object) -> void: controller_overrides = controller_overrides.filter(func(entry): return entry[\"controller\"] != controller) controller_overrides.sort_custom(func(a, b): return b[\"priority\"] - a[\"priority\"]) if controller_overrides.is_empty(): active_controller = null else: active_controller = controller_overrides[0].controller For instance, the most common use is RTS_DefaultAttackVariant , which automatically overrides the default implementation of RTS_Movable when it is active: # RTS_DefaultAttackVariant: func set_component_active(): super.set_component_active() if entity.movable != null: entity.movable.add_controller_override(self,1) func set_component_inactive(): super.set_component_inactive() if entity.movable != null: entity.movable.remove_controller_override(self) Such a controller has to implement exactly two functions: func physics_process_override_movable(delta: float, movable: RTS_Movable) and func is_externally_immovable(movable: RTS_Movable) -> bool: of which we have already discussed the latter further above. This way, RTS_DefaultAttackVariant can implement (override) its own custom movement logic, which is needed because we might not won't to continue to move when we are attacking. Note all the complex boid behaviours and state transitions are taken care of in RTS_Movable . Therefore the overriding controller doesn't have to implement custom movement logic itself, rather, it can run extra condition checks and determin which functions in the RTS_Movable should be execute. In most cases these controller still call movable.sm.updatev([delta]) at some point, which runs the default movement logic in RTS_Movable . To clarify this point, imagine you only want the default movement logic to happen when the current time in seconds in divisible by two. You could add a controller, which checks the time modulo 2, and only calls updatev([delta]) when this condition is true.","title":"Controller overrides"},{"location":"components/movable/#events","text":"signal after_targets_added(movable: RTS_Movable, targets: Array[RTS_Target]) signal next_target_changed(movable: RTS_Movable) #onyl called for acute target change signal before_all_targets_cleared(movable: RTS_Movable) signal all_targets_cleared(movable: RTS_Movable) signal next_target_just_reached(movable: RTS_Movable, target: RTS_Target) # called just before removal of index signal final_target_reached(movable: RTS_Movable)","title":"Events"},{"location":"components/overview/","text":"Component System Overview What is a Component? Components are modular pieces of functionality that can be attached to units to give them specific capabilities. Rather than building units through inheritance, you compose them from components. Component-Based Architecture Benefits Modularity - Each component handles one responsibility Reusability - Use the same components on different unit types Flexibility - Mix and match components to create varied units Testability - Components can be tested independently Performance - Only required components are active Base Component Class All components extend from the base class RTS_Component , which always has a reference to its entity (usually the parent). func fetch_entity() -> RTS_Entity: return get_parent() as RTS_Entity and can be turned on and off: func set_component_inactive(): component_is_active = false func set_component_active(): assert(!component_is_active,\"RTS_Component set active twice. You're game logic is probably flawed.\") component_is_active = true If not required otherwise, leaving set_component_active_on_ready set to true is usually the right choice. RTS_Component is the main building block for creating modular and scalable, yet unique entity behaviors. For developers wanting to adopt this framework, it is recommended to create your own unique components which add features and complexity to entities by extending this base class. Here we briefly introduce the most common components that are included in the RTS Entity Controller. Note that RTS_Ability and many other scripts (such as RTS_Weapon ) also inherit from RTS_Component . Common Components Selection & Interaction SelectableComponent - Make units clickable and selectable [BoxableComponent] - Enable box selection support, see SelectableComponent [PickablePhysics] - Enables clicking units to select using raycast, see SelectableComponent Movement & Navigation MovableComponent - Unit movement and pathfinding Health & Combat HealthComponent - Hit points and health management DefenseComponent - Armor and damage reduction Attack components - See Attack System Visuals & Animation VisualComponent - Rendering and visibility [AnimationTreeComponent] - AnimationTree and AnimationPlayer integration. Also see Attack System Example: ExampleUnit.tscn As alluded to in Entity System , components usually (but not always) sit as direct children underneath the entity: ExampleUnit (RTS_Entity) \u251c\u2500\u2500 (...) \u251c\u2500\u2500 SelectableComponent \u251c\u2500\u2500 MovableComponent \u251c\u2500\u2500 HealthComponent \u251c\u2500\u2500 DefenseComponent \u251c\u2500\u2500 AnimationTreeComponent Creating Custom Components Creating custom components is as easy as inheriting from RTS_Component . The easiest thing to forget is to properly implement func set_component_inactive() func set_component_active() so that components can be turned off which should disable any heavy computation or update loops. Next Steps Learn about specific components in the detailed guides Selectable Component Movable Component Creating custom abilities","title":"Overview"},{"location":"components/overview/#component-system-overview","text":"","title":"Component System Overview"},{"location":"components/overview/#what-is-a-component","text":"Components are modular pieces of functionality that can be attached to units to give them specific capabilities. Rather than building units through inheritance, you compose them from components.","title":"What is a Component?"},{"location":"components/overview/#component-based-architecture-benefits","text":"Modularity - Each component handles one responsibility Reusability - Use the same components on different unit types Flexibility - Mix and match components to create varied units Testability - Components can be tested independently Performance - Only required components are active","title":"Component-Based Architecture Benefits"},{"location":"components/overview/#base-component-class","text":"All components extend from the base class RTS_Component , which always has a reference to its entity (usually the parent). func fetch_entity() -> RTS_Entity: return get_parent() as RTS_Entity and can be turned on and off: func set_component_inactive(): component_is_active = false func set_component_active(): assert(!component_is_active,\"RTS_Component set active twice. You're game logic is probably flawed.\") component_is_active = true If not required otherwise, leaving set_component_active_on_ready set to true is usually the right choice. RTS_Component is the main building block for creating modular and scalable, yet unique entity behaviors. For developers wanting to adopt this framework, it is recommended to create your own unique components which add features and complexity to entities by extending this base class. Here we briefly introduce the most common components that are included in the RTS Entity Controller. Note that RTS_Ability and many other scripts (such as RTS_Weapon ) also inherit from RTS_Component .","title":"Base Component Class"},{"location":"components/overview/#common-components","text":"","title":"Common Components"},{"location":"components/overview/#selection-interaction","text":"SelectableComponent - Make units clickable and selectable [BoxableComponent] - Enable box selection support, see SelectableComponent [PickablePhysics] - Enables clicking units to select using raycast, see SelectableComponent","title":"Selection &amp; Interaction"},{"location":"components/overview/#movement-navigation","text":"MovableComponent - Unit movement and pathfinding","title":"Movement &amp; Navigation"},{"location":"components/overview/#health-combat","text":"HealthComponent - Hit points and health management DefenseComponent - Armor and damage reduction Attack components - See Attack System","title":"Health &amp; Combat"},{"location":"components/overview/#visuals-animation","text":"VisualComponent - Rendering and visibility [AnimationTreeComponent] - AnimationTree and AnimationPlayer integration. Also see Attack System","title":"Visuals &amp; Animation"},{"location":"components/overview/#example-exampleunittscn","text":"As alluded to in Entity System , components usually (but not always) sit as direct children underneath the entity: ExampleUnit (RTS_Entity) \u251c\u2500\u2500 (...) \u251c\u2500\u2500 SelectableComponent \u251c\u2500\u2500 MovableComponent \u251c\u2500\u2500 HealthComponent \u251c\u2500\u2500 DefenseComponent \u251c\u2500\u2500 AnimationTreeComponent","title":"Example: ExampleUnit.tscn"},{"location":"components/overview/#creating-custom-components","text":"Creating custom components is as easy as inheriting from RTS_Component . The easiest thing to forget is to properly implement func set_component_inactive() func set_component_active() so that components can be turned off which should disable any heavy computation or update loops.","title":"Creating Custom Components"},{"location":"components/overview/#next-steps","text":"Learn about specific components in the detailed guides Selectable Component Movable Component Creating custom abilities","title":"Next Steps"},{"location":"components/selectable/","text":"Selectable Component The SelectableComponent makes a unit clickable or box selectable, needed to issue further commands, actions or cast abilities. The component itself signifies whether an entity is selectable at all. Making a unit selectable (pickable) or box selectable (using a drawn rect) requires adding the respective RTS_PickablePhysicsComponent or RTS_BoxableComponent . Whilst RTS_PickablePhysicsComponent requires a StaticBody3D and the correct collision layer to be set (collision_layer_selection), RTS_BoxableComponent requries a CollisionShape3D to determin the bounds and intersection with the user drawn rect on screen. This collision shape can be the same static body used for pickable physics. The selection cone and hover_quad can be changed for any arbitrary meshes to toggle hover/selection visibility. @export var selection_cone: MeshInstance3D @export var hover_quad: MeshInstance3D Events signal on_stop() signal selected(value: bool) Apart from the above signal, more selection signals can be found in RTS_Selection : signal selection_changed(selection: Array[RTS_Selectable]) signal added_to_selection(selection: Array[RTS_Selectable]) signal removed_from_selection(selection: Array[RTS_Selectable]) signal hovered_pickable_set(pickable: RTS_PickablePhysicsComponent) signal hovered_pickable_unset(pickable: RTS_PickablePhysicsComponent) signal hovered_pickable_empty() signal highest_selected_changed(entity: RTS_Entity) See Also See Selection System for more details.","title":"Selectable"},{"location":"components/selectable/#selectable-component","text":"The SelectableComponent makes a unit clickable or box selectable, needed to issue further commands, actions or cast abilities. The component itself signifies whether an entity is selectable at all. Making a unit selectable (pickable) or box selectable (using a drawn rect) requires adding the respective RTS_PickablePhysicsComponent or RTS_BoxableComponent . Whilst RTS_PickablePhysicsComponent requires a StaticBody3D and the correct collision layer to be set (collision_layer_selection), RTS_BoxableComponent requries a CollisionShape3D to determin the bounds and intersection with the user drawn rect on screen. This collision shape can be the same static body used for pickable physics. The selection cone and hover_quad can be changed for any arbitrary meshes to toggle hover/selection visibility. @export var selection_cone: MeshInstance3D @export var hover_quad: MeshInstance3D","title":"Selectable Component"},{"location":"components/selectable/#events","text":"signal on_stop() signal selected(value: bool) Apart from the above signal, more selection signals can be found in RTS_Selection : signal selection_changed(selection: Array[RTS_Selectable]) signal added_to_selection(selection: Array[RTS_Selectable]) signal removed_from_selection(selection: Array[RTS_Selectable]) signal hovered_pickable_set(pickable: RTS_PickablePhysicsComponent) signal hovered_pickable_unset(pickable: RTS_PickablePhysicsComponent) signal hovered_pickable_empty() signal highest_selected_changed(entity: RTS_Entity)","title":"Events"},{"location":"components/selectable/#see-also","text":"See Selection System for more details.","title":"See Also"},{"location":"components/special/","text":"Special Components Specialized components for specific behaviors and effects. Stunnable Component Applies status effects and crowd control to units. Basic Usage extends Node3D func _ready(): add_child(Stunnable.new()) Features Stuns (complete immobilization) Slows (reduced movement speed) Roots (can't move but can act) Duration tracking Multiple simultaneous effects Applying Effects var stunnable = unit.get_node(\"Stunnable\") stunnable.stun(duration) stunnable.slow(slow_factor, duration) stunnable.root(duration) Checking Status if stunnable.is_stunned(): # Unit cannot act pass if stunnable.is_slowed(): # Reduce movement speed pass CommonAnimController Standard animation controller for common unit animations. Features Unified animation state management Walk/Run transitions Attack coordination Damage reactions Death sequences Integration Works automatically with movement and combat systems. ComponentLinker Connects components and manages dependencies. Purpose Manages component references Ensures proper initialization order Handles component communication Usage Automatically used by the addon's core systems. Custom Components Create your own specialized components: extends Component class_name MySpecialComponent func _ready() -> void: super() # Initialize special behavior pass func _process(delta: float) -> void: # Update special logic pass See Also Component System - Creating custom components Combat System - Combat with status effects Best Practices - Component design patterns","title":"Special Components"},{"location":"components/special/#special-components","text":"Specialized components for specific behaviors and effects.","title":"Special Components"},{"location":"components/special/#stunnable-component","text":"Applies status effects and crowd control to units.","title":"Stunnable Component"},{"location":"components/special/#basic-usage","text":"extends Node3D func _ready(): add_child(Stunnable.new())","title":"Basic Usage"},{"location":"components/special/#features","text":"Stuns (complete immobilization) Slows (reduced movement speed) Roots (can't move but can act) Duration tracking Multiple simultaneous effects","title":"Features"},{"location":"components/special/#applying-effects","text":"var stunnable = unit.get_node(\"Stunnable\") stunnable.stun(duration) stunnable.slow(slow_factor, duration) stunnable.root(duration)","title":"Applying Effects"},{"location":"components/special/#checking-status","text":"if stunnable.is_stunned(): # Unit cannot act pass if stunnable.is_slowed(): # Reduce movement speed pass","title":"Checking Status"},{"location":"components/special/#commonanimcontroller","text":"Standard animation controller for common unit animations.","title":"CommonAnimController"},{"location":"components/special/#features_1","text":"Unified animation state management Walk/Run transitions Attack coordination Damage reactions Death sequences","title":"Features"},{"location":"components/special/#integration","text":"Works automatically with movement and combat systems.","title":"Integration"},{"location":"components/special/#componentlinker","text":"Connects components and manages dependencies.","title":"ComponentLinker"},{"location":"components/special/#purpose","text":"Manages component references Ensures proper initialization order Handles component communication","title":"Purpose"},{"location":"components/special/#usage","text":"Automatically used by the addon's core systems.","title":"Usage"},{"location":"components/special/#custom-components","text":"Create your own specialized components: extends Component class_name MySpecialComponent func _ready() -> void: super() # Initialize special behavior pass func _process(delta: float) -> void: # Update special logic pass","title":"Custom Components"},{"location":"components/special/#see-also","text":"Component System - Creating custom components Combat System - Combat with status effects Best Practices - Component design patterns","title":"See Also"},{"location":"components/visual/","text":"Visual Component The RTS_VisualComponent 's main purpose is to hold all visual elements of the entity, in particular the ones that require a pivot point for rotation. It is the visual component, not the RTS_Entity itself which gets rotated by the attack or movement system. Properties @export var meshes : Array[MeshInstance3D] = [] @export var flash_time = 0.05 The default implementation has an optional array of MeshInstance3D , which (if the material is a StandardMaterial3D ) are flashed white (for the duration of flash_time ) when receiving damage, func on_health_damaged(_health: RTS_HealthComponent): if mats.is_empty() || timer != null: return for mat in mats: mat.emission_energy_multiplier = 1.0 timer = get_tree().create_timer(flash_time) timer.timeout.connect(on_timeout) If unwanted, simply leaving the meshes empty will not run any code. See Components Overview for system integration.","title":"Visual Component"},{"location":"components/visual/#visual-component","text":"The RTS_VisualComponent 's main purpose is to hold all visual elements of the entity, in particular the ones that require a pivot point for rotation. It is the visual component, not the RTS_Entity itself which gets rotated by the attack or movement system.","title":"Visual Component"},{"location":"components/visual/#properties","text":"@export var meshes : Array[MeshInstance3D] = [] @export var flash_time = 0.05 The default implementation has an optional array of MeshInstance3D , which (if the material is a StandardMaterial3D ) are flashed white (for the duration of flash_time ) when receiving damage, func on_health_damaged(_health: RTS_HealthComponent): if mats.is_empty() || timer != null: return for mat in mats: mat.emission_energy_multiplier = 1.0 timer = get_tree().create_timer(flash_time) timer.timeout.connect(on_timeout) If unwanted, simply leaving the meshes empty will not run any code. See Components Overview for system integration.","title":"Properties"},{"location":"reference/best-practices/","text":"Best Practices General Design Use Components Appropriately Create small, focused components One responsibility per component Avoid large monolithic scripts (Movable Component not being a good example...) Reuse components across unit types Event-Driven Communication # Good: Decoupled via events RTS_EventBus.connect(\"unit_selected\", Callable(self, \"_on_unit_selected\")) # Avoid: Direct coupling var player = get_node(\"/root/Player\") player.select_unit(unit) Cache References # Cache component references var health_comp: HealthComponent var movement_comp: MovableComponent func _ready() -> void: health_comp = get_node(\"HealthComponent\") movement_comp = get_node(\"MovableComponent\") Performance Use appropriate amount of entities This tools works best with tens to low hundreds of units. Think SC2 sized squirmishes, not thousands of units large armies. Optimize entities Perfomance is heavily influence by how complex your single units are. Try Removing any unnecessary Node3D s (or turning them into Node if possible) Optimize polygon, draw calls and generally try to combine meshes where possible Reuse Area3D where possible Track component activity using Godots profiler Batch Operations # Good: Process multiple at once var paths = [] for target in destinations: paths.append(calculate_path(start, target)) # Avoid: Individual queries in loops for i in range(100): calculate_path(start, destinations[i]) # Slow! Also note that Gdscripts function call overhead is (relatively) pretty expensive. Use Process Efficiently # Only override if needed func _process(delta: float) -> void: if active_state: # Skip if not needed update_position(delta) # Or use _physics_process for physics # Or conditionally call update methods Component Integration Proper Initialization 99% of the time, you do want to call super._ready() when overriding components, so don't forget! func _ready() -> void: super._ready() # Call parent _ready health_comp = entity.health # Use entity to fetch components if possible! # Subscribe to events RTS_EventBus.connect(\"unit_selected\", Callable(self, \"_on_selected\")) # Validate setup assert(health_comp != null, \"Missing HealthComponent\") Graceful Cleanup func _exit_tree() -> void: # Disconnect signals RTS_EventBus.disconnect(\"unit_selected\", Callable(self, \"_on_selected\")) # Cancel timers if timer: timer.stop() # Clean up resources if shader_material: shader_material.free() Selection & Input Validate Selections # Ensure units still exist before using for unit in selected_units: if not is_instance_valid(unit): continue # Unit was deleted issue_command(unit) Testing & Debugging Use Debug Tools Especially for drawing paths and geometry, using a debug drawing tools such as DebugDraw3D is immensely helpful. You will actual find commented DebugDraw3D calls throughout the code. # Add debug visualization ##DebugDraw3D.draw_aabb(aabb,debug_color) Validate Assumptions # Assert expected conditions assert(unit != null, \"Unit reference is null\") assert(unit.has_node(\"HealthComponent\"), \"Unit missing HealthComponent\") See Also Core Concepts - Architecture patterns Component System - Component design Troubleshooting - Common issues","title":"Best Practices"},{"location":"reference/best-practices/#best-practices","text":"","title":"Best Practices"},{"location":"reference/best-practices/#general-design","text":"","title":"General Design"},{"location":"reference/best-practices/#use-components-appropriately","text":"Create small, focused components One responsibility per component Avoid large monolithic scripts (Movable Component not being a good example...) Reuse components across unit types","title":"Use Components Appropriately"},{"location":"reference/best-practices/#event-driven-communication","text":"# Good: Decoupled via events RTS_EventBus.connect(\"unit_selected\", Callable(self, \"_on_unit_selected\")) # Avoid: Direct coupling var player = get_node(\"/root/Player\") player.select_unit(unit)","title":"Event-Driven Communication"},{"location":"reference/best-practices/#cache-references","text":"# Cache component references var health_comp: HealthComponent var movement_comp: MovableComponent func _ready() -> void: health_comp = get_node(\"HealthComponent\") movement_comp = get_node(\"MovableComponent\")","title":"Cache References"},{"location":"reference/best-practices/#performance","text":"","title":"Performance"},{"location":"reference/best-practices/#use-appropriate-amount-of-entities","text":"This tools works best with tens to low hundreds of units. Think SC2 sized squirmishes, not thousands of units large armies.","title":"Use appropriate amount of entities"},{"location":"reference/best-practices/#optimize-entities","text":"Perfomance is heavily influence by how complex your single units are. Try Removing any unnecessary Node3D s (or turning them into Node if possible) Optimize polygon, draw calls and generally try to combine meshes where possible Reuse Area3D where possible Track component activity using Godots profiler","title":"Optimize entities"},{"location":"reference/best-practices/#batch-operations","text":"# Good: Process multiple at once var paths = [] for target in destinations: paths.append(calculate_path(start, target)) # Avoid: Individual queries in loops for i in range(100): calculate_path(start, destinations[i]) # Slow! Also note that Gdscripts function call overhead is (relatively) pretty expensive.","title":"Batch Operations"},{"location":"reference/best-practices/#use-process-efficiently","text":"# Only override if needed func _process(delta: float) -> void: if active_state: # Skip if not needed update_position(delta) # Or use _physics_process for physics # Or conditionally call update methods","title":"Use Process Efficiently"},{"location":"reference/best-practices/#component-integration","text":"","title":"Component Integration"},{"location":"reference/best-practices/#proper-initialization","text":"99% of the time, you do want to call super._ready() when overriding components, so don't forget! func _ready() -> void: super._ready() # Call parent _ready health_comp = entity.health # Use entity to fetch components if possible! # Subscribe to events RTS_EventBus.connect(\"unit_selected\", Callable(self, \"_on_selected\")) # Validate setup assert(health_comp != null, \"Missing HealthComponent\")","title":"Proper Initialization"},{"location":"reference/best-practices/#graceful-cleanup","text":"func _exit_tree() -> void: # Disconnect signals RTS_EventBus.disconnect(\"unit_selected\", Callable(self, \"_on_selected\")) # Cancel timers if timer: timer.stop() # Clean up resources if shader_material: shader_material.free()","title":"Graceful Cleanup"},{"location":"reference/best-practices/#selection-input","text":"","title":"Selection &amp; Input"},{"location":"reference/best-practices/#validate-selections","text":"# Ensure units still exist before using for unit in selected_units: if not is_instance_valid(unit): continue # Unit was deleted issue_command(unit)","title":"Validate Selections"},{"location":"reference/best-practices/#testing-debugging","text":"","title":"Testing &amp; Debugging"},{"location":"reference/best-practices/#use-debug-tools","text":"Especially for drawing paths and geometry, using a debug drawing tools such as DebugDraw3D is immensely helpful. You will actual find commented DebugDraw3D calls throughout the code. # Add debug visualization ##DebugDraw3D.draw_aabb(aabb,debug_color)","title":"Use Debug Tools"},{"location":"reference/best-practices/#validate-assumptions","text":"# Assert expected conditions assert(unit != null, \"Unit reference is null\") assert(unit.has_node(\"HealthComponent\"), \"Unit missing HealthComponent\")","title":"Validate Assumptions"},{"location":"reference/best-practices/#see-also","text":"Core Concepts - Architecture patterns Component System - Component design Troubleshooting - Common issues","title":"See Also"},{"location":"reference/troubleshooting/","text":"Troubleshooting Common issues and how to resolve them. Units Not Selectable Problem : Can't click on units to select them. Solutions : Ensure SelectableComponent is added to unit Check collision layers/masks for raycast compatibility Verify RTS_PlayerInput is enabled Check that input event handling isn't blocked elsewhere # Debug: Check if component exists if not unit.has_node(\"SelectableComponent\"): print(\"Unit missing SelectableComponent!\") Units Not Moving Problem : Move commands don't result in unit movement. Solutions : Add MovableComponent to unit Verify NavigationRegion3D with NavMesh exists in scene Bake the NavMesh Check collision layers for path validation NavMesh Not Working Problem : Pathfinding doesn't work or units get stuck. Solutions : Open Scene menu \u2192 Bake NavMesh Ensure static obstacles are set properly Verify cell/agent sizes are appropriate Check that terrain is included in NavMesh Events Not Firing Problem : Signal connections don't work. Solutions : Verify correct signal name (case-sensitive) Ensure callback function exists Check autoloads are enabled in Project Settings Use get_tree().debug_connections to inspectgs Performance Issues Problem : Game runs slowly with many units. Solutions : Use spatial hashing for queries (see Spatial Hashing ) Reduce update frequency for non-critical systems Use object pooling for projectiles/effects Profile with Godot's profiler Remark : On modern hardware, the game should run well with up to 100 units. Consider simplifying the complexity or geometry of units if using more than that. Since Gdscript is not a perfomant language and the logic being completely writtin in gdscript, don't expect to handle multiple hundreds of units at the same time. Animation Not Playing Problem : Unit animations don't trigger. Solutions : Ensure AnimationPlayer and AnimationTree are properly set up Verify animation names match exactly Check AnimationTree parameters are set correctly Enable AnimationTree with anim_tree.active = true Be aware that an active AnimationTree overwrites the AnimationPlayer! Health/Damage Not Working Problem : Health doesn't decrease when taking damage. Solutions : Add HealthComponent to unit Verify damage is actually being applied Check if unit has defense that might block damage Inspect health events to unit Autoload Not Found Problem : RTS_EventBus, RTSController, or RTS_PlayerInput errors. Solutions : Check plugin is enabled (Project \u2192 Settings \u2192 Plugins) Reload project if adding plugin Verify autoload names in Project Settings \u2192 Autoload Check for script errors in console Settings \u2192 Plugins) Try manually adding the autoloads Collision Issues Problem : Units pass through each other or obstacles. Solutions : Configure collision layers properly, by checking rts_settings.tres Use appropriate collision shapes (not too small) Check collision layer/mask combinations Remark : Collision layers for RTS_Entity and RTS_Component should automatically be set in _ready depending on the Faction of the Entity. Getting Help If you're stuck: Check the Best Practices guide Review relevant documentation section Check the examples in the addon Enable debug output and check console Use Godot's debugger to inspect state See Also Getting Started - Initial setup Best Practices - Common patterns Core Concepts - How things work","title":"Troubleshooting"},{"location":"reference/troubleshooting/#troubleshooting","text":"Common issues and how to resolve them.","title":"Troubleshooting"},{"location":"reference/troubleshooting/#units-not-selectable","text":"Problem : Can't click on units to select them. Solutions : Ensure SelectableComponent is added to unit Check collision layers/masks for raycast compatibility Verify RTS_PlayerInput is enabled Check that input event handling isn't blocked elsewhere # Debug: Check if component exists if not unit.has_node(\"SelectableComponent\"): print(\"Unit missing SelectableComponent!\")","title":"Units Not Selectable"},{"location":"reference/troubleshooting/#units-not-moving","text":"Problem : Move commands don't result in unit movement. Solutions : Add MovableComponent to unit Verify NavigationRegion3D with NavMesh exists in scene Bake the NavMesh Check collision layers for path validation","title":"Units Not Moving"},{"location":"reference/troubleshooting/#navmesh-not-working","text":"Problem : Pathfinding doesn't work or units get stuck. Solutions : Open Scene menu \u2192 Bake NavMesh Ensure static obstacles are set properly Verify cell/agent sizes are appropriate Check that terrain is included in NavMesh","title":"NavMesh Not Working"},{"location":"reference/troubleshooting/#events-not-firing","text":"Problem : Signal connections don't work. Solutions : Verify correct signal name (case-sensitive) Ensure callback function exists Check autoloads are enabled in Project Settings Use get_tree().debug_connections to inspectgs","title":"Events Not Firing"},{"location":"reference/troubleshooting/#performance-issues","text":"Problem : Game runs slowly with many units. Solutions : Use spatial hashing for queries (see Spatial Hashing ) Reduce update frequency for non-critical systems Use object pooling for projectiles/effects Profile with Godot's profiler Remark : On modern hardware, the game should run well with up to 100 units. Consider simplifying the complexity or geometry of units if using more than that. Since Gdscript is not a perfomant language and the logic being completely writtin in gdscript, don't expect to handle multiple hundreds of units at the same time.","title":"Performance Issues"},{"location":"reference/troubleshooting/#animation-not-playing","text":"Problem : Unit animations don't trigger. Solutions : Ensure AnimationPlayer and AnimationTree are properly set up Verify animation names match exactly Check AnimationTree parameters are set correctly Enable AnimationTree with anim_tree.active = true Be aware that an active AnimationTree overwrites the AnimationPlayer!","title":"Animation Not Playing"},{"location":"reference/troubleshooting/#healthdamage-not-working","text":"Problem : Health doesn't decrease when taking damage. Solutions : Add HealthComponent to unit Verify damage is actually being applied Check if unit has defense that might block damage Inspect health events to unit","title":"Health/Damage Not Working"},{"location":"reference/troubleshooting/#autoload-not-found","text":"Problem : RTS_EventBus, RTSController, or RTS_PlayerInput errors. Solutions : Check plugin is enabled (Project \u2192 Settings \u2192 Plugins) Reload project if adding plugin Verify autoload names in Project Settings \u2192 Autoload Check for script errors in console Settings \u2192 Plugins) Try manually adding the autoloads","title":"Autoload Not Found"},{"location":"reference/troubleshooting/#collision-issues","text":"Problem : Units pass through each other or obstacles. Solutions : Configure collision layers properly, by checking rts_settings.tres Use appropriate collision shapes (not too small) Check collision layer/mask combinations Remark : Collision layers for RTS_Entity and RTS_Component should automatically be set in _ready depending on the Faction of the Entity.","title":"Collision Issues"},{"location":"reference/troubleshooting/#getting-help","text":"If you're stuck: Check the Best Practices guide Review relevant documentation section Check the examples in the addon Enable debug output and check console Use Godot's debugger to inspect state","title":"Getting Help"},{"location":"reference/troubleshooting/#see-also","text":"Getting Started - Initial setup Best Practices - Common patterns Core Concepts - How things work","title":"See Also"},{"location":"systems/abilities/","text":"Abilities System Overview Abilities are special actions that units can perform, such as spells, skills, or special attacks. They support cooldowns, costs, effects, and animations. Creating an Ability Similar to RTS_Entity , in order to separate data from the execution logic, static data pertaining to an ability, such as its id, cooldown duration or action points is defined in the AbilityResource resource. AbilityResource Start by creating an ability resource: class_name AbilityResource extends Resource @export var id: StringName #must be same as action input name @export var is_common: bool = false # if is_common, always executable if entity is selected @export var allow_trigger_multiple = false #can trigger multiple abilities with single button press @export var activate_as_group = false # calls activate_group once instead of activate individually for reach ability @export var cooldown_duration : float = 0.0 #cooldown in seconds @export var is_chainable: bool = true #if false, ability will immediately be activated, even when shift pressed @export var display: bool = true #if false, ui will not display this icon (remove RTS_SImpleUI scene if unwanted) @export var display_ap: bool = true @export var init_ap: int = 1 @export var max_ap: int = 1 @export var ap_cost: int = 1 @export var icon_normal: Texture2D @export var icon_hover: Texture2D @export var icon_pressed: Texture2D @export var description: String #optional description for ability tooltip A quick explanation of the above properties follows. is_common : Used to differentiate between common abilities (such as moving, patrolling, stopping) and unit unique abilities (such as a special attack of a certain unit). In the default implementation, this will for instance determine whether the UI displays the ability in the bottom left (common), or bottom right (special) corner. If use_highest_entity_for_ability_selection in the rts_settings.tres is set to true, this will also result in non-common abilities of only the highest selected unit to be displayed. This is for instance the behaviour in the RTS Starcraft2, where (apart from certain standard abilities), only the unit in the selected units with the highest priority can cast its spells. allow_trigger_multiple : If true, ALL selected entities with the same ability will activate their ability. If false, only one will do so. activate_as_group : If true, func activate_group(abilities: Array): instead of func activate(): on the ability will be called. Useful if special group behaviour is required, for instance for formation walking (see RTS_MoveAbility) cooldown_duration : If positive, requires the time in seconds to elapse before ability can be cast again is_chainable : If false, abilities are immediately activated. If true, the ability will only activate or cast when the next movement target is reach. Imagine a \"Sniping ability\" that will only start casting once you've reached the next movement point. (This requires you to have chain the ability by pressing Ctrl + ) display : If false, default UI does not display the action display_ap : If false, default UI does not display action points. init_ap : How many action points the entity initial has, for this ability. max_ap : How many action points the entity can maximally have, for this ability. ap_cost : How many action points it costs to activate this ability description : Optional description of the ability, used by the default UI. Icon normal/hover/pressed are the textures displayed by the default UI in the left/right corner, when a ability is enabled/hovered/activated. If you're using a custom UI you can ignore these fields. RTS_Ability After creating the resource, you can inherit from RTS_Ability to implement your custom ability logic. For a simple reference, check out RTS_MoveAbility or RTS_HoldAbility Ability Types There are three basic Ability Component types, which you can extend, RTS_Ability : Base class, providing functions such as activate() , activate_group() . RTS_ClickAbility : Inherting base class and adding functionality to cast abilities that require a target. Adds additional functionality, such as is_valid_target() or can_cast() . Note that activating this ability can potentially not immediately call cast() , for instance when the casting target is out of range. Additional casting properties, such as auto_move_to_cast , cast_min_range or cast_max_range can be set in the corresponding ClickAbilityResource . ClickAbilities can be cancelled by right clicking after activating them (before casting). To cast, left click the target. RTS_ToggleAbility : Extending the base class by adding a toggle on/off state to the ability. # RTS_ToggleAbility enum State { DEACTIVATED, ACTIVATED } RTS_AbilityManager The managing script that parses and interprets input (coming from PlayerInput), and activates the respective abilities on one or more entities, either separately or as group. It handles complex behaviour such as chaining abilities (which adds a callback to activate certain abilities when the next move target is reached), and auto moving towards cast targets for RTS_ClickAbility . The default implementation of RTS_AbilityManager supports two \"modes\", depending on whether use_highest_entity_for_ability_selection in rts_settings.tres is enabled or not. Standard (not enabled). Any ability of any selected entity (that doesn't have an active cooldown and enough AP) can be activated. SC2-Style (activated). Only the special abilties of the \"highest\" selected entity (this is determined viat the @export var priority: int property on RTS_Selectable) can be activated. Common abilities (of all units) can always be activated. See Also Combat System - Damage and health Attack System - Basic attacks","title":"Abilities System"},{"location":"systems/abilities/#abilities-system","text":"","title":"Abilities System"},{"location":"systems/abilities/#overview","text":"Abilities are special actions that units can perform, such as spells, skills, or special attacks. They support cooldowns, costs, effects, and animations.","title":"Overview"},{"location":"systems/abilities/#creating-an-ability","text":"Similar to RTS_Entity , in order to separate data from the execution logic, static data pertaining to an ability, such as its id, cooldown duration or action points is defined in the AbilityResource resource.","title":"Creating an Ability"},{"location":"systems/abilities/#abilityresource","text":"Start by creating an ability resource: class_name AbilityResource extends Resource @export var id: StringName #must be same as action input name @export var is_common: bool = false # if is_common, always executable if entity is selected @export var allow_trigger_multiple = false #can trigger multiple abilities with single button press @export var activate_as_group = false # calls activate_group once instead of activate individually for reach ability @export var cooldown_duration : float = 0.0 #cooldown in seconds @export var is_chainable: bool = true #if false, ability will immediately be activated, even when shift pressed @export var display: bool = true #if false, ui will not display this icon (remove RTS_SImpleUI scene if unwanted) @export var display_ap: bool = true @export var init_ap: int = 1 @export var max_ap: int = 1 @export var ap_cost: int = 1 @export var icon_normal: Texture2D @export var icon_hover: Texture2D @export var icon_pressed: Texture2D @export var description: String #optional description for ability tooltip A quick explanation of the above properties follows. is_common : Used to differentiate between common abilities (such as moving, patrolling, stopping) and unit unique abilities (such as a special attack of a certain unit). In the default implementation, this will for instance determine whether the UI displays the ability in the bottom left (common), or bottom right (special) corner. If use_highest_entity_for_ability_selection in the rts_settings.tres is set to true, this will also result in non-common abilities of only the highest selected unit to be displayed. This is for instance the behaviour in the RTS Starcraft2, where (apart from certain standard abilities), only the unit in the selected units with the highest priority can cast its spells. allow_trigger_multiple : If true, ALL selected entities with the same ability will activate their ability. If false, only one will do so. activate_as_group : If true, func activate_group(abilities: Array): instead of func activate(): on the ability will be called. Useful if special group behaviour is required, for instance for formation walking (see RTS_MoveAbility) cooldown_duration : If positive, requires the time in seconds to elapse before ability can be cast again is_chainable : If false, abilities are immediately activated. If true, the ability will only activate or cast when the next movement target is reach. Imagine a \"Sniping ability\" that will only start casting once you've reached the next movement point. (This requires you to have chain the ability by pressing Ctrl + ) display : If false, default UI does not display the action display_ap : If false, default UI does not display action points. init_ap : How many action points the entity initial has, for this ability. max_ap : How many action points the entity can maximally have, for this ability. ap_cost : How many action points it costs to activate this ability description : Optional description of the ability, used by the default UI. Icon normal/hover/pressed are the textures displayed by the default UI in the left/right corner, when a ability is enabled/hovered/activated. If you're using a custom UI you can ignore these fields.","title":"AbilityResource"},{"location":"systems/abilities/#rts_ability","text":"After creating the resource, you can inherit from RTS_Ability to implement your custom ability logic. For a simple reference, check out RTS_MoveAbility or RTS_HoldAbility","title":"RTS_Ability"},{"location":"systems/abilities/#ability-types","text":"There are three basic Ability Component types, which you can extend, RTS_Ability : Base class, providing functions such as activate() , activate_group() . RTS_ClickAbility : Inherting base class and adding functionality to cast abilities that require a target. Adds additional functionality, such as is_valid_target() or can_cast() . Note that activating this ability can potentially not immediately call cast() , for instance when the casting target is out of range. Additional casting properties, such as auto_move_to_cast , cast_min_range or cast_max_range can be set in the corresponding ClickAbilityResource . ClickAbilities can be cancelled by right clicking after activating them (before casting). To cast, left click the target. RTS_ToggleAbility : Extending the base class by adding a toggle on/off state to the ability. # RTS_ToggleAbility enum State { DEACTIVATED, ACTIVATED }","title":"Ability Types"},{"location":"systems/abilities/#rts_abilitymanager","text":"The managing script that parses and interprets input (coming from PlayerInput), and activates the respective abilities on one or more entities, either separately or as group. It handles complex behaviour such as chaining abilities (which adds a callback to activate certain abilities when the next move target is reached), and auto moving towards cast targets for RTS_ClickAbility . The default implementation of RTS_AbilityManager supports two \"modes\", depending on whether use_highest_entity_for_ability_selection in rts_settings.tres is enabled or not. Standard (not enabled). Any ability of any selected entity (that doesn't have an active cooldown and enough AP) can be activated. SC2-Style (activated). Only the special abilties of the \"highest\" selected entity (this is determined viat the @export var priority: int property on RTS_Selectable) can be activated. Common abilities (of all units) can always be activated.","title":"RTS_AbilityManager"},{"location":"systems/abilities/#see-also","text":"Combat System - Damage and health Attack System - Basic attacks","title":"See Also"},{"location":"systems/autoloads/","text":"Autoloads Overview The Godot RTS Entity Controller uses three main autoloads to manage the entire system. These are automatically initialized when the plugin is enabled. RTS_EventBus Purpose : Central event dispatcher for events to avoid tight component coupling RTSController Purpose : Loading essential RTS components that glue everything together This scene is not mandatory, but it included for ease of use and demonstration purposes. You could customize the scene or split this into separate scenes to your likings, as long as all the essential components, such as the Camera Rig, Movement or Selection sripts are provided. Perhaps most likely you would want to change the UI. In that case you could duplicate this scene and simply take out the CanvasLayer. Remark : In case you do decide to change this scene (or use your own) just make sure the scripts found on the RTSController node are still accessible via RTS_Controls. for the scripts to work (since many scripts access them using the Controls autloaded script) Overview : RTSController: Holds references to the scripts and managers for easy referencing Selection: Handles selection of entities PhysicsSelection: Handles non-box-selection, i.e. Raycast (click) selection of entities Movement: Handles group movement and patrol logic of entities Paths: Adds/Removes visible paths and target points for entity movement AbilityManager: Interprets player input and activates abilities on selected units MainRig: Handles camera movement MainCamera: Handles Raycasting/Projection logic CanvasLayer: Simple UI Layer PoolManager: Simple implementation of pooling logic for paths and waypoints Geometry: GeometryUtilies Time: Time related functionality RTS_PlayerInput Purpose : Handles player input and and distributes it to the respective systems. See PlayerInputSystem","title":"Autoloads"},{"location":"systems/autoloads/#autoloads-overview","text":"The Godot RTS Entity Controller uses three main autoloads to manage the entire system. These are automatically initialized when the plugin is enabled.","title":"Autoloads Overview"},{"location":"systems/autoloads/#rts_eventbus","text":"Purpose : Central event dispatcher for events to avoid tight component coupling","title":"RTS_EventBus"},{"location":"systems/autoloads/#rtscontroller","text":"Purpose : Loading essential RTS components that glue everything together This scene is not mandatory, but it included for ease of use and demonstration purposes. You could customize the scene or split this into separate scenes to your likings, as long as all the essential components, such as the Camera Rig, Movement or Selection sripts are provided. Perhaps most likely you would want to change the UI. In that case you could duplicate this scene and simply take out the CanvasLayer. Remark : In case you do decide to change this scene (or use your own) just make sure the scripts found on the RTSController node are still accessible via RTS_Controls. for the scripts to work (since many scripts access them using the Controls autloaded script) Overview : RTSController: Holds references to the scripts and managers for easy referencing Selection: Handles selection of entities PhysicsSelection: Handles non-box-selection, i.e. Raycast (click) selection of entities Movement: Handles group movement and patrol logic of entities Paths: Adds/Removes visible paths and target points for entity movement AbilityManager: Interprets player input and activates abilities on selected units MainRig: Handles camera movement MainCamera: Handles Raycasting/Projection logic CanvasLayer: Simple UI Layer PoolManager: Simple implementation of pooling logic for paths and waypoints Geometry: GeometryUtilies Time: Time related functionality","title":"RTSController"},{"location":"systems/autoloads/#rts_playerinput","text":"Purpose : Handles player input and and distributes it to the respective systems. See PlayerInputSystem","title":"RTS_PlayerInput"},{"location":"systems/combat/","text":"Combat System Overview Godot RTS Entity Controller provides a modular set of Attack and Weapon logic that can be easily extended and changed to achieve unique attack and AI behaviour. The main components needed to implement attack and damage dealing logic are: RTS_AttackComponent : Holds the common, shared logic of tracking targets within scan/weapon range and manages state (IDLE, COOLDOWN, ATTACKING). RTS_AnimationTreeComponent : Required component for RTS_AttackComponent to handle animation and attack durations. RTS_AttackVariant (default implementation: RTS_DefaultAttackVariant) : Implements RTS_AttackComponent's states explicitly, i.e. how to behave (mainly movement) during each state. RTS_Weapon : Holds weapon specific logic and data, such as cooldown duration, modifiers, damage dealing logic etc RTS_DamageDealer : Used (not exclusively) by weapon to deal damage to a RTS_Defense A typical damage dealing entity should have a structure something like the following Entity (RTS_Entity) \u251c\u2500\u2500 AnimationPlayer \u251c\u2500\u2500 AnimationTree (RTS_AnimationTreeComponent) \u2514\u2500\u2500 AttackComponent (RTS_AttackComponent) \u251c\u2500\u2500 Weapon (RTS_Weapon) \u2514\u2500\u2500 Damage (RTS_DamageDealer) \u2514\u2500\u2500 Variant (RTS_AttackVariant) although the amount of weapons, damage dealer and variants might vary. Let's look at each component in more detail and use the minimalistic ExampleUnit.tscn as an example. Components RTS_AttackComponent The main component of the combat system. While a single entity can hold and switch between multiple weapons or attack variants, there should only be one RTS_AttackComponent acting as the orchestrator for the system. The component emits useful signals, signal target_changed(attack: RTS_AttackComponent, old_target: RTS_Defense, new_target: RTS_Defense) signal target_became_not_null(attack: RTS_AttackComponent, new_target: RTS_Defense) signal target_became_null(attack: RTS_AttackComponent, old_target: RTS_Defense) signal player_assigned_target_death(attack: RTS_AttackComponent, player_assigned_target: RTS_Defense) signal current_target_death(attack: RTS_AttackComponent, target: RTS_Defense) signal active_weapon_changed(new_weapon: RTS_Weapon,weapon_index: int) holds state, enum State { IDLE =0, ATTACKING =1, COOLDOWN =2 } and holds references to the entities weapons and attack variants: #in _ready for child in children: if child is RTS_Weapon: weapons.append(child) if child is RTS_AttackVariant: variants.append(child) Even when only using a single attack variant and weapon, such as ExampleUnit.tscn, it is recommended to always set the weapon and attack variants set_component_active_on_ready field to false, and let the attack component decide which attack variant or weapon to activate in _ready: @export var variant_to_activate_on_ready: RTS_AttackVariant @export var weapon_to_activate_on_ready: RTS_Weapon This should become obvious when using multiple weapons or attack variants (of which only one, respectively, can be active at a time). The support for multipl weapons/attack variants can be thought of as the entity being able to wield different weapons (for example ground vs anti-air weapons), and different associated behaviours (normal attack mode, siege attack mode). Interplay with RTS_AnimationTreeComponent An integral part to the combat system and successful state transitions between IDLE, COOLDOWN and ATTACKING is the RTS_AnimationTreeComponent and the AnimationPlayer. In order to understand the remaining two properties of RTS_AttackComponent, ## Required to find out when anim has entered attacking @export var attack_nodes: Dictionary[StringName,bool] = { \"attack\": true } @export var use_overlay_anim_for_attack_duration: bool = false it is important to understand the interplay of these components. When an enemy unit is attacked, the RTS_AttackComponents state changes to \"ATTACKING\". This alone does not automatically deal damage or play an animation. Rather, it is the RTS_AnimationTreeComponent's statemachines job, to react to this state change and play an attack animation. Inspecting the ExampleUnits AnimationTreeComponents AnimationNodeStateMachine, we can see the transition from state \"idle\" to \"attack\" checks whether the attack state is 1, or ATTACKING. Note the \"Advance Condition Base Node\" of the AnimationTreeComponent is RTS_Entity, as explained in Entity System Here is where the attack_nodes property comes into play. When name of the entered node is contained in the attack_nodes dictionary, we're telling RTS_AttackComponent that the attack animation has started. By default the name \"attack\" is included, but you could add multiple different attack nodes playing different attack animations, and add each of their name to the dictionary. If use_overlay_anim_for_attack_duration is false, RTS_AttackComponent will wait for the animation AnimationTreeComponent's associated AnimationPlayer to finish to feedback the end of the attack animation. In other words, the state transition from ATTACKING to IDLE or COOLDOWN as well as the attack duration depend on the attack animation (which is played using the AnimationTree) to play correctly. This coupling of the AnimatationTree's AnimationPlayer and attack state logic might not always be preferable. For example, one might want to use slightly different timings, or modify the \"attack animation\" but can't easily do this due to the models animation player being part of an imported scene (i.e. a gltf blender file). In this case, one can use an additional AnimationPlayer and set it as the RTS_AnimationTreeComponent's overlay_anim_player to use this animation players animation to determine the attack duration. In this case, to inform the RTS_AttackComponent of which animation it has to keep track of, you need to add a map from the state machines node name (above: \"attack\") to the overlayed animation players animation name (ideally called the same as the node name, \"attack\"). Remark : The reason for this slightly annoying system of having to listen to the animation player's animation, instead of using the state machine's nodes directly, is that, as of Godot 4, the state machine nodes do not have built in callbacks for when animations or states have finished. The state machine simply acts as a controller to advance the AnimationPlayers animation. Some people might find it easier to interpret to above logic directly by looking at the relevent code: func on_tree_node_entered(node: StringName): if attack_nodes.has(node): var anim_tree: RTS_AnimationTreeComponent = entity.anim_tree anim_tree.tree_node_entered.disconnect(on_tree_node_entered) if use_overlay_anim_for_attack_duration: anim_tree.overlay_anim_player.animation_finished.connect(on_attack_anim_finished) assert(anim_tree.overlay_anim_player.current_animation_length > 0) else: anim_tree.animation_finished.connect(on_attack_anim_finished) assert(anim_tree.playback.get_current_length() > 0) start_immobilization_timer(active_weapon.attack_immobilize_duration) RTS_AttackVariant RTS_AttackComponent can switch between multiple RTS_AttackVariant's via set_active_variant(...) . The main purpose of this is so that the state logic func state_idle(): pass func state_cooldown(): pass func state_attacking(): pass can be implement in different flavors. Most, if not all but certain special units, probably want to use the RTS_DefaultAttackVariant implementation of RTS_AttackVariant. ExampleUnit.tscn demonstrate how this variant behaves. It exposes a few options to lock or override rotation during attack/cooldown, @export var attack_overrides_rotation = true @export var cooldown_overrides_rotation = true and implements basic AI behavior, which automatically tries to attack enemy units if in range via try_move_attack_chased_target(...) . RTS_Weapon So far we have explained how attack state (and transitions) are managed via RTS_AttackComponent and RTS_AnimationTreeComponent, and how RTS_AttackVariant implements moving and AI logic, but no actual damage has been dealt anywhere. This is where RTS_Weapons come into play. Simple call its use() function to deal damage to its active target. This target (called last_weapon_target ) is automatically set and updated by the other components introduced earlier. While it is possible to make this call from anywhere, the best place is probably to add a function call from the attack animation itself (the original or the overlay attack animation if using one): ExampleUnit.tscn uses RTS_InstantDamageWeapon to deal instant damage to its targets (using the RTS_DamageDealer, see below.). One could write more complex weapons that inherit from RTS_Weapon and shoot projectiles or use the SpatialHashArea to deal AoE damage. Weapon and Scan Areas RTS_AttackComponent uses weapon and scan areas to determine which enemy defense areas (set up in RTS_DefenseComponent ) it overlaps and collides with. RTS_DefenseComponent s within the Weapon range can be attacked. As soon as there is at least on valid target within weapon range, the combat system will try to attack this target. Defenses within the Scan range cannot yet be attacked, but are being tracked by RTS_AttackComponent and (depending on the AttackVariant logic) automatically chased down to attack. See the RTS_DefaultAttackVariants 's try_move_attack_chased_target for details if curious. RTS_DamageDealer A simple node holding damage information used to damage RTS_Defenses. @export var publisher: RTS_Entity #optional, who is dealing this damage @export var from: Node3D #optional, where is the damage dealt from. usually publisher.global_position, but can also be projetile position @export var damage: float = 1.0 Whilst optional, publisher and from should always bet set if possible. Without a publisher , a damage receiving entity won't know from which other entity the damage came from, for example in order to pursue and counter attack it. Similarly, from is used to determin the exact position where the damage has come from, for example to do spatial calculations useful for vfx and shaders. See Also Defense Component - Health management Abilities System - Ability details","title":"Combat System"},{"location":"systems/combat/#combat-system","text":"","title":"Combat System"},{"location":"systems/combat/#overview","text":"Godot RTS Entity Controller provides a modular set of Attack and Weapon logic that can be easily extended and changed to achieve unique attack and AI behaviour. The main components needed to implement attack and damage dealing logic are: RTS_AttackComponent : Holds the common, shared logic of tracking targets within scan/weapon range and manages state (IDLE, COOLDOWN, ATTACKING). RTS_AnimationTreeComponent : Required component for RTS_AttackComponent to handle animation and attack durations. RTS_AttackVariant (default implementation: RTS_DefaultAttackVariant) : Implements RTS_AttackComponent's states explicitly, i.e. how to behave (mainly movement) during each state. RTS_Weapon : Holds weapon specific logic and data, such as cooldown duration, modifiers, damage dealing logic etc RTS_DamageDealer : Used (not exclusively) by weapon to deal damage to a RTS_Defense A typical damage dealing entity should have a structure something like the following Entity (RTS_Entity) \u251c\u2500\u2500 AnimationPlayer \u251c\u2500\u2500 AnimationTree (RTS_AnimationTreeComponent) \u2514\u2500\u2500 AttackComponent (RTS_AttackComponent) \u251c\u2500\u2500 Weapon (RTS_Weapon) \u2514\u2500\u2500 Damage (RTS_DamageDealer) \u2514\u2500\u2500 Variant (RTS_AttackVariant) although the amount of weapons, damage dealer and variants might vary. Let's look at each component in more detail and use the minimalistic ExampleUnit.tscn as an example.","title":"Overview"},{"location":"systems/combat/#components","text":"","title":"Components"},{"location":"systems/combat/#rts_attackcomponent","text":"The main component of the combat system. While a single entity can hold and switch between multiple weapons or attack variants, there should only be one RTS_AttackComponent acting as the orchestrator for the system. The component emits useful signals, signal target_changed(attack: RTS_AttackComponent, old_target: RTS_Defense, new_target: RTS_Defense) signal target_became_not_null(attack: RTS_AttackComponent, new_target: RTS_Defense) signal target_became_null(attack: RTS_AttackComponent, old_target: RTS_Defense) signal player_assigned_target_death(attack: RTS_AttackComponent, player_assigned_target: RTS_Defense) signal current_target_death(attack: RTS_AttackComponent, target: RTS_Defense) signal active_weapon_changed(new_weapon: RTS_Weapon,weapon_index: int) holds state, enum State { IDLE =0, ATTACKING =1, COOLDOWN =2 } and holds references to the entities weapons and attack variants: #in _ready for child in children: if child is RTS_Weapon: weapons.append(child) if child is RTS_AttackVariant: variants.append(child) Even when only using a single attack variant and weapon, such as ExampleUnit.tscn, it is recommended to always set the weapon and attack variants set_component_active_on_ready field to false, and let the attack component decide which attack variant or weapon to activate in _ready: @export var variant_to_activate_on_ready: RTS_AttackVariant @export var weapon_to_activate_on_ready: RTS_Weapon This should become obvious when using multiple weapons or attack variants (of which only one, respectively, can be active at a time). The support for multipl weapons/attack variants can be thought of as the entity being able to wield different weapons (for example ground vs anti-air weapons), and different associated behaviours (normal attack mode, siege attack mode).","title":"RTS_AttackComponent"},{"location":"systems/combat/#interplay-with-rts_animationtreecomponent","text":"An integral part to the combat system and successful state transitions between IDLE, COOLDOWN and ATTACKING is the RTS_AnimationTreeComponent and the AnimationPlayer. In order to understand the remaining two properties of RTS_AttackComponent, ## Required to find out when anim has entered attacking @export var attack_nodes: Dictionary[StringName,bool] = { \"attack\": true } @export var use_overlay_anim_for_attack_duration: bool = false it is important to understand the interplay of these components. When an enemy unit is attacked, the RTS_AttackComponents state changes to \"ATTACKING\". This alone does not automatically deal damage or play an animation. Rather, it is the RTS_AnimationTreeComponent's statemachines job, to react to this state change and play an attack animation. Inspecting the ExampleUnits AnimationTreeComponents AnimationNodeStateMachine, we can see the transition from state \"idle\" to \"attack\" checks whether the attack state is 1, or ATTACKING. Note the \"Advance Condition Base Node\" of the AnimationTreeComponent is RTS_Entity, as explained in Entity System Here is where the attack_nodes property comes into play. When name of the entered node is contained in the attack_nodes dictionary, we're telling RTS_AttackComponent that the attack animation has started. By default the name \"attack\" is included, but you could add multiple different attack nodes playing different attack animations, and add each of their name to the dictionary. If use_overlay_anim_for_attack_duration is false, RTS_AttackComponent will wait for the animation AnimationTreeComponent's associated AnimationPlayer to finish to feedback the end of the attack animation. In other words, the state transition from ATTACKING to IDLE or COOLDOWN as well as the attack duration depend on the attack animation (which is played using the AnimationTree) to play correctly. This coupling of the AnimatationTree's AnimationPlayer and attack state logic might not always be preferable. For example, one might want to use slightly different timings, or modify the \"attack animation\" but can't easily do this due to the models animation player being part of an imported scene (i.e. a gltf blender file). In this case, one can use an additional AnimationPlayer and set it as the RTS_AnimationTreeComponent's overlay_anim_player to use this animation players animation to determine the attack duration. In this case, to inform the RTS_AttackComponent of which animation it has to keep track of, you need to add a map from the state machines node name (above: \"attack\") to the overlayed animation players animation name (ideally called the same as the node name, \"attack\"). Remark : The reason for this slightly annoying system of having to listen to the animation player's animation, instead of using the state machine's nodes directly, is that, as of Godot 4, the state machine nodes do not have built in callbacks for when animations or states have finished. The state machine simply acts as a controller to advance the AnimationPlayers animation. Some people might find it easier to interpret to above logic directly by looking at the relevent code: func on_tree_node_entered(node: StringName): if attack_nodes.has(node): var anim_tree: RTS_AnimationTreeComponent = entity.anim_tree anim_tree.tree_node_entered.disconnect(on_tree_node_entered) if use_overlay_anim_for_attack_duration: anim_tree.overlay_anim_player.animation_finished.connect(on_attack_anim_finished) assert(anim_tree.overlay_anim_player.current_animation_length > 0) else: anim_tree.animation_finished.connect(on_attack_anim_finished) assert(anim_tree.playback.get_current_length() > 0) start_immobilization_timer(active_weapon.attack_immobilize_duration)","title":"Interplay with RTS_AnimationTreeComponent"},{"location":"systems/combat/#rts_attackvariant","text":"RTS_AttackComponent can switch between multiple RTS_AttackVariant's via set_active_variant(...) . The main purpose of this is so that the state logic func state_idle(): pass func state_cooldown(): pass func state_attacking(): pass can be implement in different flavors. Most, if not all but certain special units, probably want to use the RTS_DefaultAttackVariant implementation of RTS_AttackVariant. ExampleUnit.tscn demonstrate how this variant behaves. It exposes a few options to lock or override rotation during attack/cooldown, @export var attack_overrides_rotation = true @export var cooldown_overrides_rotation = true and implements basic AI behavior, which automatically tries to attack enemy units if in range via try_move_attack_chased_target(...) .","title":"RTS_AttackVariant"},{"location":"systems/combat/#rts_weapon","text":"So far we have explained how attack state (and transitions) are managed via RTS_AttackComponent and RTS_AnimationTreeComponent, and how RTS_AttackVariant implements moving and AI logic, but no actual damage has been dealt anywhere. This is where RTS_Weapons come into play. Simple call its use() function to deal damage to its active target. This target (called last_weapon_target ) is automatically set and updated by the other components introduced earlier. While it is possible to make this call from anywhere, the best place is probably to add a function call from the attack animation itself (the original or the overlay attack animation if using one): ExampleUnit.tscn uses RTS_InstantDamageWeapon to deal instant damage to its targets (using the RTS_DamageDealer, see below.). One could write more complex weapons that inherit from RTS_Weapon and shoot projectiles or use the SpatialHashArea to deal AoE damage.","title":"RTS_Weapon"},{"location":"systems/combat/#weapon-and-scan-areas","text":"RTS_AttackComponent uses weapon and scan areas to determine which enemy defense areas (set up in RTS_DefenseComponent ) it overlaps and collides with. RTS_DefenseComponent s within the Weapon range can be attacked. As soon as there is at least on valid target within weapon range, the combat system will try to attack this target. Defenses within the Scan range cannot yet be attacked, but are being tracked by RTS_AttackComponent and (depending on the AttackVariant logic) automatically chased down to attack. See the RTS_DefaultAttackVariants 's try_move_attack_chased_target for details if curious.","title":"Weapon and Scan Areas"},{"location":"systems/combat/#rts_damagedealer","text":"A simple node holding damage information used to damage RTS_Defenses. @export var publisher: RTS_Entity #optional, who is dealing this damage @export var from: Node3D #optional, where is the damage dealt from. usually publisher.global_position, but can also be projetile position @export var damage: float = 1.0 Whilst optional, publisher and from should always bet set if possible. Without a publisher , a damage receiving entity won't know from which other entity the damage came from, for example in order to pursue and counter attack it. Similarly, from is used to determin the exact position where the damage has come from, for example to do spatial calculations useful for vfx and shaders.","title":"RTS_DamageDealer"},{"location":"systems/combat/#see-also","text":"Defense Component - Health management Abilities System - Ability details","title":"See Also"},{"location":"systems/entity/","text":"RTS_Entity: The Core Unit Host Overview RTS_Entity is the central hub that hosts and coordinates all components for a unit in the RTS Entity Controller. It extends CharacterBody3D and acts as the owner/parent that manages component lifecycle, state coordination, and integration with the broader system. An Entity can represent anything from a movable Unit to an immovable structure such as a building. The Host/Owner Pattern Rather than components being standalone, they are children of the RTS_Entity node which acts as their host and orchestrator. Why This Design? Centralized State - Entity manages all component state in one place Easy Discovery - Components are automatically found and cached Physics Support - CharacterBody3D provides physics and collision support Spatial Hashing - Entity represents a spatial unit for queries Lifecycle Management - Entity emits useful lifecycle events EntityResource Basic data, such as the entities name, id or thumbnail should be configured by creating a EntityResource resource, from which the RTS_Entity can read. Component Discovery & Caching RTS_Entity automatically discovers components on startup: @export var selectable: RTS_Selectable @export var movable: RTS_Movable @export var health: RTS_HealthComponent @export var attack: RTS_AttackComponent @export var defense: RTS_Defense @export var stunnable: RTS_StunnableComponent @export var anim_tree: RTS_AnimationTreeComponent @export var visuals: RTS_VisualComponent @export var obstacle: NavigationObstacleComponent In _ready() , the entity calls update_and_fetch_components() : func update_and_fetch_components(): abilities.clear() abilities_array.clear() for child in get_children(): if child is RTS_Selectable: selectable = child if child is RTS_Movable: movable = child if child is RTS_HealthComponent: health = child # ... etc for all components This means: No manual setup needed - Just add components as children Components are cached - Accessed via properties, not get_node() calls Type-safe - Full IDE autocomplete support Since the script as @tool annotated, this happens during editor time, to avoid race conditions during startup. Faction System Entities belong to factions that determine team affiliation: enum Faction { PLAYER, ENEMY, NEUTRAL } @export var faction = Faction.PLAYER Use faction to: - Determine ally/enemy relationships - Set collision layers - Control targeting - Manage rendering/highlighting func setup_unit(_faction: Faction): faction = _faction # Faction affects collision detection and team relationships Component Coordination The entity coordinates between components by connecting signals and routing events: Component State & Animation Sync if movable: movable.sm.enter_state.connect(on_movable_enter_state) on_movable_enter_state(movable.sm.current_state) When the certain component changes states, the entity updates its own state dictionaries: var sb : Dictionary[StringName, bool] = {} #state bool var si : Dictionary[StringName, int] = {} #state integer At first this might seem redundant and look like unnecessary coupling, however this is done so the AnimationTree a central place to check state for its State Transitions. Unforuntately the advanced expressions in Godots StateMachines can only evaluate state from one script (called the \"AdvancedExpressionBaseNode\") and the Entity is the perfect candidate to read this state from. Thus you can evaluate any state easily in the AnimationTree's StateMachine, for instance si[\"move_state\"] = new_state # Which movement state si[\"attack_state\"] = new_state # Which attack state sb[\"is_stunned\"] = value # Stunned status si[\"weapon_index\"] = weapon_index # Current weapon Ability Management RTS_Entity automatically collects and manages abilities: var abilities: Dictionary[String, RTS_Ability] = {} var abilities_array: Array[RTS_Ability] = [] All RTS_Ability components are discovered and stored by ID: if child is RTS_Ability: abilities_array.append(child) abilities[child.resource.id] = child Access abilities by name or iterate: # Get specific ability var fireball = entity.abilities[\"fireball\"] # Iterate all for ability in entity.abilities_array: ability.use(target) Spatial Hashing Integration The entity integrates with spatial hashing for efficient queries: @export var space_hash: bool = true: set(value): space_hash = value When set to false, the spatial hash system will not include this entity as a \"client\" in its grid. This can be efficient to set to false for immovable structures or entities that don't require special quering, to reduce workload on the spatial hash system. Lifecycle Events The entity emits important lifecycle signals: signal before_tree_exit(entity: RTS_Entity) signal end_of_life(entity: RTS_Entity) # Guaranteed exactly once These allow other systems to track unit creation and destruction. Screen Visibility Track when units enter/exit screen for optimization: visible_on_screen.screen_entered.connect(on_screen_entered) visible_on_screen.screen_exited.connect(on_screen_exited) func on_screen_entered(): RTS_EventBus.entity_screen_visible.emit(self, true) Use this to: - Stop processing off-screen units - Optimize rendering - Control audio playback Accessing Entity from Components Every component implements the func fetch_entity() -> RTS_Entity to easily fetch the corresponding entity. Creating a Custom Entity RTS_Entity can be extended for unique behaviour, i.e. class_name HeroUnit extends RTS_Entity @export var experience: int = 0 but before you do, think twice and reconsider if this additional behavior can not rather be implement using a new component, to keep your entities modular! Best Practices 1. Always Check Component Existence (since they are optional) # Good if entity.health: entity.health.take_damage(10) # Avoid entity.health.take_damage(10) # Crashes if health component missing 2. Use Entity as Central Coordinator Even though certain components technically depend on each other (for instance RTS_Defense requires a RTS_Health to work an deal damage), it is usually best to query this component from RTS_Entity, to avoid coupling and spaghetti references. 3. Leverage Caching # Good - Cached reference var health = entity.health for i in range(100): health.current_hp -= 1 # Avoid - Repeated node lookups for i in range(100): entity.get_node(\"RTS_HealthComponent\").current_hp -= 1 See Also Component System - Creating components Getting Started - Setting up units Best Practices - Design patterns","title":"Entity System"},{"location":"systems/entity/#rts_entity-the-core-unit-host","text":"","title":"RTS_Entity: The Core Unit Host"},{"location":"systems/entity/#overview","text":"RTS_Entity is the central hub that hosts and coordinates all components for a unit in the RTS Entity Controller. It extends CharacterBody3D and acts as the owner/parent that manages component lifecycle, state coordination, and integration with the broader system. An Entity can represent anything from a movable Unit to an immovable structure such as a building.","title":"Overview"},{"location":"systems/entity/#the-hostowner-pattern","text":"Rather than components being standalone, they are children of the RTS_Entity node which acts as their host and orchestrator.","title":"The Host/Owner Pattern"},{"location":"systems/entity/#why-this-design","text":"Centralized State - Entity manages all component state in one place Easy Discovery - Components are automatically found and cached Physics Support - CharacterBody3D provides physics and collision support Spatial Hashing - Entity represents a spatial unit for queries Lifecycle Management - Entity emits useful lifecycle events","title":"Why This Design?"},{"location":"systems/entity/#entityresource","text":"Basic data, such as the entities name, id or thumbnail should be configured by creating a EntityResource resource, from which the RTS_Entity can read.","title":"EntityResource"},{"location":"systems/entity/#component-discovery-caching","text":"RTS_Entity automatically discovers components on startup: @export var selectable: RTS_Selectable @export var movable: RTS_Movable @export var health: RTS_HealthComponent @export var attack: RTS_AttackComponent @export var defense: RTS_Defense @export var stunnable: RTS_StunnableComponent @export var anim_tree: RTS_AnimationTreeComponent @export var visuals: RTS_VisualComponent @export var obstacle: NavigationObstacleComponent In _ready() , the entity calls update_and_fetch_components() : func update_and_fetch_components(): abilities.clear() abilities_array.clear() for child in get_children(): if child is RTS_Selectable: selectable = child if child is RTS_Movable: movable = child if child is RTS_HealthComponent: health = child # ... etc for all components This means: No manual setup needed - Just add components as children Components are cached - Accessed via properties, not get_node() calls Type-safe - Full IDE autocomplete support Since the script as @tool annotated, this happens during editor time, to avoid race conditions during startup.","title":"Component Discovery &amp; Caching"},{"location":"systems/entity/#faction-system","text":"Entities belong to factions that determine team affiliation: enum Faction { PLAYER, ENEMY, NEUTRAL } @export var faction = Faction.PLAYER Use faction to: - Determine ally/enemy relationships - Set collision layers - Control targeting - Manage rendering/highlighting func setup_unit(_faction: Faction): faction = _faction # Faction affects collision detection and team relationships","title":"Faction System"},{"location":"systems/entity/#component-coordination","text":"The entity coordinates between components by connecting signals and routing events:","title":"Component Coordination"},{"location":"systems/entity/#component-state-animation-sync","text":"if movable: movable.sm.enter_state.connect(on_movable_enter_state) on_movable_enter_state(movable.sm.current_state) When the certain component changes states, the entity updates its own state dictionaries: var sb : Dictionary[StringName, bool] = {} #state bool var si : Dictionary[StringName, int] = {} #state integer At first this might seem redundant and look like unnecessary coupling, however this is done so the AnimationTree a central place to check state for its State Transitions. Unforuntately the advanced expressions in Godots StateMachines can only evaluate state from one script (called the \"AdvancedExpressionBaseNode\") and the Entity is the perfect candidate to read this state from. Thus you can evaluate any state easily in the AnimationTree's StateMachine, for instance si[\"move_state\"] = new_state # Which movement state si[\"attack_state\"] = new_state # Which attack state sb[\"is_stunned\"] = value # Stunned status si[\"weapon_index\"] = weapon_index # Current weapon","title":"Component State &amp; Animation Sync"},{"location":"systems/entity/#ability-management","text":"RTS_Entity automatically collects and manages abilities: var abilities: Dictionary[String, RTS_Ability] = {} var abilities_array: Array[RTS_Ability] = [] All RTS_Ability components are discovered and stored by ID: if child is RTS_Ability: abilities_array.append(child) abilities[child.resource.id] = child Access abilities by name or iterate: # Get specific ability var fireball = entity.abilities[\"fireball\"] # Iterate all for ability in entity.abilities_array: ability.use(target)","title":"Ability Management"},{"location":"systems/entity/#spatial-hashing-integration","text":"The entity integrates with spatial hashing for efficient queries: @export var space_hash: bool = true: set(value): space_hash = value When set to false, the spatial hash system will not include this entity as a \"client\" in its grid. This can be efficient to set to false for immovable structures or entities that don't require special quering, to reduce workload on the spatial hash system.","title":"Spatial Hashing Integration"},{"location":"systems/entity/#lifecycle-events","text":"The entity emits important lifecycle signals: signal before_tree_exit(entity: RTS_Entity) signal end_of_life(entity: RTS_Entity) # Guaranteed exactly once These allow other systems to track unit creation and destruction.","title":"Lifecycle Events"},{"location":"systems/entity/#screen-visibility","text":"Track when units enter/exit screen for optimization: visible_on_screen.screen_entered.connect(on_screen_entered) visible_on_screen.screen_exited.connect(on_screen_exited) func on_screen_entered(): RTS_EventBus.entity_screen_visible.emit(self, true) Use this to: - Stop processing off-screen units - Optimize rendering - Control audio playback","title":"Screen Visibility"},{"location":"systems/entity/#accessing-entity-from-components","text":"Every component implements the func fetch_entity() -> RTS_Entity to easily fetch the corresponding entity.","title":"Accessing Entity from Components"},{"location":"systems/entity/#creating-a-custom-entity","text":"RTS_Entity can be extended for unique behaviour, i.e. class_name HeroUnit extends RTS_Entity @export var experience: int = 0 but before you do, think twice and reconsider if this additional behavior can not rather be implement using a new component, to keep your entities modular!","title":"Creating a Custom Entity"},{"location":"systems/entity/#best-practices","text":"","title":"Best Practices"},{"location":"systems/entity/#1-always-check-component-existence-since-they-are-optional","text":"# Good if entity.health: entity.health.take_damage(10) # Avoid entity.health.take_damage(10) # Crashes if health component missing","title":"1. Always Check Component Existence (since they are optional)"},{"location":"systems/entity/#2-use-entity-as-central-coordinator","text":"Even though certain components technically depend on each other (for instance RTS_Defense requires a RTS_Health to work an deal damage), it is usually best to query this component from RTS_Entity, to avoid coupling and spaghetti references.","title":"2. Use Entity as Central Coordinator"},{"location":"systems/entity/#3-leverage-caching","text":"# Good - Cached reference var health = entity.health for i in range(100): health.current_hp -= 1 # Avoid - Repeated node lookups for i in range(100): entity.get_node(\"RTS_HealthComponent\").current_hp -= 1","title":"3. Leverage Caching"},{"location":"systems/entity/#see-also","text":"Component System - Creating components Getting Started - Setting up units Best Practices - Design patterns","title":"See Also"},{"location":"systems/movement/","text":"Movement & Navigation Overview The movement system uses a mix of Godot's built-in navigation system for seeking a target position (static) and various custom avoidance and separation boid behaviours (dynamic) implement in RTS_Movable. Architecture RTS_Movement This script handleds group and formation logic. Contrary to its name, it doesn't implement any concrete movement logic itself, but rather converts movement commands of multiple RTS_Movable's into concret target points that it then sends to each respective RTS_Movable. This logic is done in group_move and group_patrol . RTS_Movable The logic that handles the details of seeking, avoidance and separation between moving entities is RTS_Movable . For details see Movable Component Issuing movement commands Instead of hardcoding movement commands, or have the PlayerInput directly dictate move commands to RTS_Movable, commands are issued via the generic [Ability System], for example via RTS_MoveAbility, RTS_AttackAbility, RTS_PatrolAbility or RTS_HoldAbility. An example: # RTS_PatrolAbility: func activate(): var movables : Array[RTS_Movable] = [] movables.append(entity.movable) RTS_Controls.movement.group_patrol( click_target, click_target_source, movables, context[\"shift_is_pressed\"], ) activated.emit(self) This way it is easy to deactivate or disable certain move commands, for example by simply removing the ability from an entity. For instance, ff you wanted an entity that can only move but not patrol, simple remove the \"RTS_PatrolAbility\" from the entity (or disable it somehow), and you can no longer issue patrol commands to the entity. To learn more about abilities see [Ability System] See Also MovableComponent - Component details Core Concepts - Architecture overview Spatial Hashing - Performance optimization","title":"Movement & Navigation"},{"location":"systems/movement/#movement-navigation","text":"","title":"Movement &amp; Navigation"},{"location":"systems/movement/#overview","text":"The movement system uses a mix of Godot's built-in navigation system for seeking a target position (static) and various custom avoidance and separation boid behaviours (dynamic) implement in RTS_Movable.","title":"Overview"},{"location":"systems/movement/#architecture","text":"","title":"Architecture"},{"location":"systems/movement/#rts_movement","text":"This script handleds group and formation logic. Contrary to its name, it doesn't implement any concrete movement logic itself, but rather converts movement commands of multiple RTS_Movable's into concret target points that it then sends to each respective RTS_Movable. This logic is done in group_move and group_patrol .","title":"RTS_Movement"},{"location":"systems/movement/#rts_movable","text":"The logic that handles the details of seeking, avoidance and separation between moving entities is RTS_Movable . For details see Movable Component","title":"RTS_Movable"},{"location":"systems/movement/#issuing-movement-commands","text":"Instead of hardcoding movement commands, or have the PlayerInput directly dictate move commands to RTS_Movable, commands are issued via the generic [Ability System], for example via RTS_MoveAbility, RTS_AttackAbility, RTS_PatrolAbility or RTS_HoldAbility. An example: # RTS_PatrolAbility: func activate(): var movables : Array[RTS_Movable] = [] movables.append(entity.movable) RTS_Controls.movement.group_patrol( click_target, click_target_source, movables, context[\"shift_is_pressed\"], ) activated.emit(self) This way it is easy to deactivate or disable certain move commands, for example by simply removing the ability from an entity. For instance, ff you wanted an entity that can only move but not patrol, simple remove the \"RTS_PatrolAbility\" from the entity (or disable it somehow), and you can no longer issue patrol commands to the entity. To learn more about abilities see [Ability System]","title":"Issuing movement commands"},{"location":"systems/movement/#see-also","text":"MovableComponent - Component details Core Concepts - Architecture overview Spatial Hashing - Performance optimization","title":"See Also"},{"location":"systems/player-input/","text":"Player Input System The Player Input System translates raw player input into game commands like unit selection, movement, and camera control. Overview The RTS_PlayerInput autoload collects input pertaining to: Unit Selection - Click to select, drag to box select Movement Commands - Right-click to move selected units Ability Activation - Keyboard shortcuts for unit abilities Camera Control - Pan, rotate, and zoom the camera Event Generation - Emits events for other systems to handle All input actions should automatically be added to the Input Map in Godot when enabling the plugin. Remark : There seems to be a Godot bug where the added input actions don't immediately show up. Try manually adding a new input action or restarting the editor for the actions to show up. Basic Usage As long as the PlayerInput is loaded (as Autoload or included somewhere else in the scene), all input should be distributed to the respective systems. One can choose to customize or overwrite the provided PlayerInput by disabling the Autoload and collecting input oneself. Just make sure the required input (found in PlayerInput) is distributed to the required components; Selection and AbilityManager. Selection Single Selection Left Click on a unit to select it Previous selection is deselected Multiple Selection (Box Select) Left Click + Drag to create a selection box All units within the box are selected Adds to current selection if holding Shift Clears previous selection otherwise Movement Commands Move Selected Units Right Click on a destination point All selected units will move to that location Uses pathfinding for intelligent navigation Chain Move While holding Ctrl it is possible to chain multiple movement targets This logic is not limited to movement, but is a general trait of the Ability Component Camera Control Pan Move Mouse to the edge of the screen Zoom Mouse Wheel up/down Adjusts camera distance from focus point Respects min/max zoom constraints Raycasting & Targeting The input system uses raycasting to determine: Which unit was clicked (Layer Selection) Where movement commands should send units (Layer Selection/Navigation) Whether the click hit the ground or an object (Layer Selection/Navigation) Configure layers and masks in your rst_settings.tres and project settings for proper raycasting behavior. See Also Core Concepts - System overview Selection System - Detailed selection logic Movement & Navigation - How units move","title":"Player Input System"},{"location":"systems/player-input/#player-input-system","text":"The Player Input System translates raw player input into game commands like unit selection, movement, and camera control.","title":"Player Input System"},{"location":"systems/player-input/#overview","text":"The RTS_PlayerInput autoload collects input pertaining to: Unit Selection - Click to select, drag to box select Movement Commands - Right-click to move selected units Ability Activation - Keyboard shortcuts for unit abilities Camera Control - Pan, rotate, and zoom the camera Event Generation - Emits events for other systems to handle All input actions should automatically be added to the Input Map in Godot when enabling the plugin. Remark : There seems to be a Godot bug where the added input actions don't immediately show up. Try manually adding a new input action or restarting the editor for the actions to show up.","title":"Overview"},{"location":"systems/player-input/#basic-usage","text":"As long as the PlayerInput is loaded (as Autoload or included somewhere else in the scene), all input should be distributed to the respective systems. One can choose to customize or overwrite the provided PlayerInput by disabling the Autoload and collecting input oneself. Just make sure the required input (found in PlayerInput) is distributed to the required components; Selection and AbilityManager.","title":"Basic Usage"},{"location":"systems/player-input/#selection","text":"","title":"Selection"},{"location":"systems/player-input/#single-selection","text":"Left Click on a unit to select it Previous selection is deselected","title":"Single Selection"},{"location":"systems/player-input/#multiple-selection-box-select","text":"Left Click + Drag to create a selection box All units within the box are selected Adds to current selection if holding Shift Clears previous selection otherwise","title":"Multiple Selection (Box Select)"},{"location":"systems/player-input/#movement-commands","text":"","title":"Movement Commands"},{"location":"systems/player-input/#move-selected-units","text":"Right Click on a destination point All selected units will move to that location Uses pathfinding for intelligent navigation","title":"Move Selected Units"},{"location":"systems/player-input/#chain-move","text":"While holding Ctrl it is possible to chain multiple movement targets This logic is not limited to movement, but is a general trait of the Ability Component","title":"Chain Move"},{"location":"systems/player-input/#camera-control","text":"","title":"Camera Control"},{"location":"systems/player-input/#pan","text":"Move Mouse to the edge of the screen","title":"Pan"},{"location":"systems/player-input/#zoom","text":"Mouse Wheel up/down Adjusts camera distance from focus point Respects min/max zoom constraints","title":"Zoom"},{"location":"systems/player-input/#raycasting-targeting","text":"The input system uses raycasting to determine: Which unit was clicked (Layer Selection) Where movement commands should send units (Layer Selection/Navigation) Whether the click hit the ground or an object (Layer Selection/Navigation) Configure layers and masks in your rst_settings.tres and project settings for proper raycasting behavior.","title":"Raycasting &amp; Targeting"},{"location":"systems/player-input/#see-also","text":"Core Concepts - System overview Selection System - Detailed selection logic Movement & Navigation - How units move","title":"See Also"},{"location":"systems/selection/","text":"Selection System Overview The Selection System manages which units are currently selected and provides feedback to the player about their selection. Only entities with the RTS_Selectable component can be selected. There are two types of selection: Pickable (using physics raycast) or Boxable (using click and drag box). A RTS_Selectable can have one or both of these types of selection configured. How Selection Works Single Unit Selection RTS_PhysicsSelection uses RTS_PickablePhysicsComponent to determine hovered entities Player clicks on an entity. If the entity is hovered, RTS_Selection selects the entity Necessary events are emitted Note that Selection keeps track of the RTS_Selectable component, not RTS_Entity itself, since selection only cares about entities which have the RTS_Selectable component Multiple Unit Selection Shift+Click Adds entity to current selection Previous units remain selected Box Select (Drag) Drag from one point to another All RTS_BoxableComponent units within the box are selected Can be combined with Shift to add to selection Deselecting Units By defaults unit can not be deselected. Only when selecting another entity does the previous selected entity get deselected. RTS_Selectable The RTS_Selectable component enables a unit to be selected. Use the priority integer to determine which entity has the highest priority, for example when selecting entities of different types. This might be useful for casting abilities, or displaying the entity UI of only the highest priority entity. Populate RTS_Selectable's pickable (ideally as a child component) to make the entity pickable (selection via mouse click), populate the boxable component to make it selectable via click and drag. RTS_Boxable Requires a collision_shape CollisionShape3D to determine the bounds for the box selection. This collision_shape has to be of type CapsuleShape3D or BoxShape3D . RTS_PickablePhysicsComponent Requires a static_body StaticBody3D used for raycasting to determine whether a unit can be selected (when hovered) Selection Feedback RTS_Selectable toggles the visibilty of the following meshes to visually show hover/selection state. @export var selection_cone: MeshInstance3D @export var hover_quad: MeshInstance3D Programmatic Selection While usually not needed, use RTS_Selection if you want to manually add entities to the selection. #Add one or multiple entities selection.add_to_selection_bulk(...) # Remove from selection selection.remove_from_selection_bulk(...) Spatial selection queries: For spatial selections (finding units within a certain radius of a point) see Spatial Hashing See Also Player Input System - How input triggers selection Selectable Component - Component details Core Concepts - Architecture overview","title":"Selection System"},{"location":"systems/selection/#selection-system","text":"","title":"Selection System"},{"location":"systems/selection/#overview","text":"The Selection System manages which units are currently selected and provides feedback to the player about their selection. Only entities with the RTS_Selectable component can be selected. There are two types of selection: Pickable (using physics raycast) or Boxable (using click and drag box). A RTS_Selectable can have one or both of these types of selection configured.","title":"Overview"},{"location":"systems/selection/#how-selection-works","text":"","title":"How Selection Works"},{"location":"systems/selection/#single-unit-selection","text":"RTS_PhysicsSelection uses RTS_PickablePhysicsComponent to determine hovered entities Player clicks on an entity. If the entity is hovered, RTS_Selection selects the entity Necessary events are emitted Note that Selection keeps track of the RTS_Selectable component, not RTS_Entity itself, since selection only cares about entities which have the RTS_Selectable component","title":"Single Unit Selection"},{"location":"systems/selection/#multiple-unit-selection","text":"","title":"Multiple Unit Selection"},{"location":"systems/selection/#shiftclick","text":"Adds entity to current selection Previous units remain selected","title":"Shift+Click"},{"location":"systems/selection/#box-select-drag","text":"Drag from one point to another All RTS_BoxableComponent units within the box are selected Can be combined with Shift to add to selection","title":"Box Select (Drag)"},{"location":"systems/selection/#deselecting-units","text":"By defaults unit can not be deselected. Only when selecting another entity does the previous selected entity get deselected.","title":"Deselecting Units"},{"location":"systems/selection/#rts_selectable","text":"The RTS_Selectable component enables a unit to be selected. Use the priority integer to determine which entity has the highest priority, for example when selecting entities of different types. This might be useful for casting abilities, or displaying the entity UI of only the highest priority entity. Populate RTS_Selectable's pickable (ideally as a child component) to make the entity pickable (selection via mouse click), populate the boxable component to make it selectable via click and drag.","title":"RTS_Selectable"},{"location":"systems/selection/#rts_boxable","text":"Requires a collision_shape CollisionShape3D to determine the bounds for the box selection. This collision_shape has to be of type CapsuleShape3D or BoxShape3D .","title":"RTS_Boxable"},{"location":"systems/selection/#rts_pickablephysicscomponent","text":"Requires a static_body StaticBody3D used for raycasting to determine whether a unit can be selected (when hovered)","title":"RTS_PickablePhysicsComponent"},{"location":"systems/selection/#selection-feedback","text":"RTS_Selectable toggles the visibilty of the following meshes to visually show hover/selection state. @export var selection_cone: MeshInstance3D @export var hover_quad: MeshInstance3D","title":"Selection Feedback"},{"location":"systems/selection/#programmatic-selection","text":"While usually not needed, use RTS_Selection if you want to manually add entities to the selection. #Add one or multiple entities selection.add_to_selection_bulk(...) # Remove from selection selection.remove_from_selection_bulk(...)","title":"Programmatic Selection"},{"location":"systems/selection/#spatial-selection-queries","text":"For spatial selections (finding units within a certain radius of a point) see Spatial Hashing","title":"Spatial selection queries:"},{"location":"systems/selection/#see-also","text":"Player Input System - How input triggers selection Selectable Component - Component details Core Concepts - Architecture overview","title":"See Also"}]}